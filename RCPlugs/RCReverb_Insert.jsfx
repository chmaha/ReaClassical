NoIndex: true
desc:RCReverb Insert (chmaha)
// Fons Adriaensen's Zita-Rev1 Reverb Algorithm
// Original: Fons Adriaensen (Kokkini Zita)
// Source: https://kokkinizita.linuxaudio.org/linuxaudio/downloads/index.html
// License: GNU General Public License version 3

slider1:40<20,100,1>Delay (ms)
slider2:200<50,1000,1>XOver (Hz)
slider3:1.5<0.5,2,0.1>Bass Multiplier
slider4:2.0<1,8,0.1>RT Mid (s)
slider5:6000<1500,24000,100>F Damp (Hz)
slider6:160<40,2500,1>EQ1 Freq (Hz)
slider7:0<-15,15,0.5>EQ1 Gain (dB)
slider8:2500<160,10000,1>EQ2 Freq (Hz)
slider9:0<-15,15,0.5>EQ2 Gain (dB)
slider10:0.5<0,1,0.01>Output Mix

@init

// Memory allocation helper
function alloc(sz) (
  memset((alloc.top += sz) - sz, 0, sz);
);

function set_filt_params(del, tmf, tlo, wlo_in, thi, chi_in)
local(g_val, t_val)
(
  this.gmf = pow(0.001, del / tmf);
  this.glo = pow(0.001, del / tlo) / this.gmf - 1.0;
  this.wlo = wlo_in;
  g_val = pow(0.001, del / thi) / this.gmf;
  t_val = (1 - g_val * g_val) / (2 * g_val * g_val * chi_in);
  this.whi = (sqrt(1 + 4 * t_val) - 1) / (2 * t_val);
);

// Diff1 delay times from source (in seconds)
tdiff1_0 = 20346*10^-6;
tdiff1_1 = 24421*10^-6;
tdiff1_2 = 31604*10^-6;
tdiff1_3 = 27333*10^-6;
tdiff1_4 = 22904*10^-6;
tdiff1_5 = 29291*10^-6;
tdiff1_6 = 13458*10^-6;
tdiff1_7 = 19123*10^-6;

// Delay times from source (in seconds)
tdelay_0 = 153129*10^-6;
tdelay_1 = 210389*10^-6;
tdelay_2 = 127837*10^-6;
tdelay_3 = 256891*10^-6;
tdelay_4 = 174713*10^-6;
tdelay_5 = 192303*10^-6;
tdelay_6 = 125000*10^-6;
tdelay_7 = 219991*10^-6;

// Variable delay lines (for input pre-delay)
vdelay0_size = floor(0.1 * srate);
vdelay0_line = alloc(vdelay0_size);
vdelay0_ir = 0;
vdelay0_iw = 0;

vdelay1_size = floor(0.1 * srate);
vdelay1_line = alloc(vdelay1_size);
vdelay1_ir = 0;
vdelay1_iw = 0;

// Diff1 (allpass diffusers) - 8 of them
diff1_0_size = floor(tdiff1_0 * srate + 0.5);
diff1_0_line = alloc(diff1_0_size);
diff1_0_i = 0;
diff1_0_c = 0.6;

diff1_1_size = floor(tdiff1_1 * srate + 0.5);
diff1_1_line = alloc(diff1_1_size);
diff1_1_i = 0;
diff1_1_c = -0.6;

diff1_2_size = floor(tdiff1_2 * srate + 0.5);
diff1_2_line = alloc(diff1_2_size);
diff1_2_i = 0;
diff1_2_c = 0.6;

diff1_3_size = floor(tdiff1_3 * srate + 0.5);
diff1_3_line = alloc(diff1_3_size);
diff1_3_i = 0;
diff1_3_c = -0.6;

diff1_4_size = floor(tdiff1_4 * srate + 0.5);
diff1_4_line = alloc(diff1_4_size);
diff1_4_i = 0;
diff1_4_c = 0.6;

diff1_5_size = floor(tdiff1_5 * srate + 0.5);
diff1_5_line = alloc(diff1_5_size);
diff1_5_i = 0;
diff1_5_c = -0.6;

diff1_6_size = floor(tdiff1_6 * srate + 0.5);
diff1_6_line = alloc(diff1_6_size);
diff1_6_i = 0;
diff1_6_c = 0.6;

diff1_7_size = floor(tdiff1_7 * srate + 0.5);
diff1_7_line = alloc(diff1_7_size);
diff1_7_i = 0;
diff1_7_c = -0.6;

// Main delay lines (after subtracting diff1 sizes)
delay_0_size = floor(tdelay_0 * srate + 0.5) - diff1_0_size;
delay_0_line = alloc(delay_0_size);
delay_0_i = 0;

delay_1_size = floor(tdelay_1 * srate + 0.5) - diff1_1_size;
delay_1_line = alloc(delay_1_size);
delay_1_i = 0;

delay_2_size = floor(tdelay_2 * srate + 0.5) - diff1_2_size;
delay_2_line = alloc(delay_2_size);
delay_2_i = 0;

delay_3_size = floor(tdelay_3 * srate + 0.5) - diff1_3_size;
delay_3_line = alloc(delay_3_size);
delay_3_i = 0;

delay_4_size = floor(tdelay_4 * srate + 0.5) - diff1_4_size;
delay_4_line = alloc(delay_4_size);
delay_4_i = 0;

delay_5_size = floor(tdelay_5 * srate + 0.5) - diff1_5_size;
delay_5_line = alloc(delay_5_size);
delay_5_i = 0;

delay_6_size = floor(tdelay_6 * srate + 0.5) - diff1_6_size;
delay_6_line = alloc(delay_6_size);
delay_6_i = 0;

delay_7_size = floor(tdelay_7 * srate + 0.5) - diff1_7_size;
delay_7_line = alloc(delay_7_size);
delay_7_i = 0;

// Initialize Filt1 states (damping filters)
filt1_0_slo = 0;
filt1_0_shi = 0;
filt1_1_slo = 0;
filt1_1_shi = 0;
filt1_2_slo = 0;
filt1_2_shi = 0;
filt1_3_slo = 0;
filt1_3_shi = 0;
filt1_4_slo = 0;
filt1_4_shi = 0;
filt1_5_slo = 0;
filt1_5_shi = 0;
filt1_6_slo = 0;
filt1_6_shi = 0;
filt1_7_slo = 0;
filt1_7_shi = 0;

// Pareq states
pareq1_z1_l = 0;
pareq1_z2_l = 0;
pareq1_z1_r = 0;
pareq1_z2_r = 0;
pareq2_z1_l = 0;
pareq2_z2_l = 0;
pareq2_z1_r = 0;
pareq2_z2_r = 0;

pareq1_state = 0;
pareq2_state = 0;
pareq1_g1 = 1.0;
pareq1_f1 = 1000.0;
pareq2_g1 = 1.0;
pareq2_f1 = 1000.0;

// Output gain states
g0 = 0.75;
g1 = 0.371;
d0 = 0;
d1 = 0;

@slider

ipdel = slider1 * 0.001;
xover = slider2;
rtlow = slider3*slider4;
rtmid = slider4;
fdamp = slider5;
eq1_freq = slider6;
eq1_gain = slider7;
eq2_freq = slider8;
eq2_gain = slider9;
opmix = slider10;

@block

k = floor((ipdel - 0.020) * srate + 0.5);
k = max(0, min(k, vdelay0_size - 1));
vdelay0_del = k;
vdelay1_del = k;

wlo = 6.2832 * xover / srate;
(fdamp > 0.49 * srate) ? (
  chi = 2;
) : (
  chi = 1 - cos(6.2832 * fdamp / srate);
);

t0 = (1 - opmix) * (1 + opmix);
t1 = 0.7 * opmix * (2 - opmix) / sqrt(rtmid);
d0 = (t0 - g0) / samplesblock;
d1 = (t1 - g1) / samplesblock;

pareq1_g0 = pow(10.0, 0.05 * eq1_gain);
pareq1_f0 = eq1_freq;
pareq2_g0 = pow(10.0, 0.05 * eq2_gain);
pareq2_f0 = eq2_freq;

filt1_0.set_filt_params(tdelay_0, rtmid, rtlow, wlo, 0.5 * rtmid, chi);
filt1_1.set_filt_params(tdelay_1, rtmid, rtlow, wlo, 0.5 * rtmid, chi);
filt1_2.set_filt_params(tdelay_2, rtmid, rtlow, wlo, 0.5 * rtmid, chi);
filt1_3.set_filt_params(tdelay_3, rtmid, rtlow, wlo, 0.5 * rtmid, chi);
filt1_4.set_filt_params(tdelay_4, rtmid, rtlow, wlo, 0.5 * rtmid, chi);
filt1_5.set_filt_params(tdelay_5, rtmid, rtlow, wlo, 0.5 * rtmid, chi);
filt1_6.set_filt_params(tdelay_6, rtmid, rtlow, wlo, 0.5 * rtmid, chi);
filt1_7.set_filt_params(tdelay_7, rtmid, rtlow, wlo, 0.5 * rtmid, chi);

function pareq_calcpar(g, f)
local(b, c1, c2, gg, ff)
(
  ff = f * $pi / srate;
  b = 2 * ff / sqrt(g);
  gg = 0.5 * (g - 1);
  c1 = -cos(2 * ff);
  c2 = (1 - b) / (1 + b);
  this.c1 = c1;
  this.c2 = c2;
  this.gg = gg;
);

pareq1_upd = 0;
(pareq1_g0 != pareq1_g1) ? (
  pareq1_upd = 1;
  (pareq1_g0 > 2 * pareq1_g1) ? pareq1_g1 *= 2
  : (pareq1_g1 > 2 * pareq1_g0) ? pareq1_g1 /= 2
  : pareq1_g1 = pareq1_g0;
);
(pareq1_f0 != pareq1_f1) ? (
  pareq1_upd = 1;
  (pareq1_f0 > 2 * pareq1_f1) ? pareq1_f1 *= 2
  : (pareq1_f1 > 2 * pareq1_f0) ? pareq1_f1 /= 2
  : pareq1_f1 = pareq1_f0;
);
(pareq1_upd) ? (
  pareq1.pareq_calcpar(pareq1_g1, pareq1_f1);
  pareq1_state = 1;
) : (
  (abs(pareq1_g1 - 1) < 0.001) ? (
    pareq1_state = 0;
    pareq1_z1_l = 0; pareq1_z2_l = 0;
    pareq1_z1_r = 0; pareq1_z2_r = 0;
  ) : pareq1_state = 1;
);

pareq2_upd = 0;
(pareq2_g0 != pareq2_g1) ? (
  pareq2_upd = 1;
  (pareq2_g0 > 2 * pareq2_g1) ? pareq2_g1 *= 2
  : (pareq2_g1 > 2 * pareq2_g0) ? pareq2_g1 /= 2
  : pareq2_g1 = pareq2_g0;
);
(pareq2_f0 != pareq2_f1) ? (
  pareq2_upd = 1;
  (pareq2_f0 > 2 * pareq2_f1) ? pareq2_f1 *= 2
  : (pareq2_f1 > 2 * pareq2_f0) ? pareq2_f1 /= 2
  : pareq2_f1 = pareq2_f0;
);
(pareq2_upd) ? (
  pareq2.pareq_calcpar(pareq2_g1, pareq2_f1);
  pareq2_state = 1;
) : (
  (abs(pareq2_g1 - 1) < 0.001) ? (
    pareq2_state = 0;
    pareq2_z1_l = 0; pareq2_z2_l = 0;
    pareq2_z1_r = 0; pareq2_z2_r = 0;
  ) : pareq2_state = 1;
);

@sample

vdelay0_line[vdelay0_iw] = spl0;
vdelay0_iw += 1;
(vdelay0_iw >= vdelay0_size) ? vdelay0_iw = 0;

vdelay1_line[vdelay1_iw] = spl1;
vdelay1_iw += 1;
(vdelay1_iw >= vdelay1_size) ? vdelay1_iw = 0;

vdelay0_rd = vdelay0_iw - vdelay0_del;
(vdelay0_rd < 0) ? vdelay0_rd += vdelay0_size;
vd0 = vdelay0_line[vdelay0_rd];

vdelay1_rd = vdelay1_iw - vdelay1_del;
(vdelay1_rd < 0) ? vdelay1_rd += vdelay1_size;
vd1 = vdelay1_line[vdelay1_rd];

t = 0.3 * vd0;

z0 = diff1_0_line[diff1_0_i];
inp0 = delay_0_line[delay_0_i] + t;
inp0 -= diff1_0_c * z0;
diff1_0_line[diff1_0_i] = inp0;
diff1_0_i += 1;
(diff1_0_i >= diff1_0_size) ? diff1_0_i = 0;
x0 = z0 + diff1_0_c * inp0;

z1 = diff1_1_line[diff1_1_i];
inp1 = delay_1_line[delay_1_i] + t;
inp1 -= diff1_1_c * z1;
diff1_1_line[diff1_1_i] = inp1;
diff1_1_i += 1;
(diff1_1_i >= diff1_1_size) ? diff1_1_i = 0;
x1 = z1 + diff1_1_c * inp1;

z2 = diff1_2_line[diff1_2_i];
inp2 = delay_2_line[delay_2_i] - t;
inp2 -= diff1_2_c * z2;
diff1_2_line[diff1_2_i] = inp2;
diff1_2_i += 1;
(diff1_2_i >= diff1_2_size) ? diff1_2_i = 0;
x2 = z2 + diff1_2_c * inp2;

z3 = diff1_3_line[diff1_3_i];
inp3 = delay_3_line[delay_3_i] - t;
inp3 -= diff1_3_c * z3;
diff1_3_line[diff1_3_i] = inp3;
diff1_3_i += 1;
(diff1_3_i >= diff1_3_size) ? diff1_3_i = 0;
x3 = z3 + diff1_3_c * inp3;

t = 0.3 * vd1;

z4 = diff1_4_line[diff1_4_i];
inp4 = delay_4_line[delay_4_i] + t;
inp4 -= diff1_4_c * z4;
diff1_4_line[diff1_4_i] = inp4;
diff1_4_i += 1;
(diff1_4_i >= diff1_4_size) ? diff1_4_i = 0;
x4 = z4 + diff1_4_c * inp4;

z5 = diff1_5_line[diff1_5_i];
inp5 = delay_5_line[delay_5_i] + t;
inp5 -= diff1_5_c * z5;
diff1_5_line[diff1_5_i] = inp5;
diff1_5_i += 1;
(diff1_5_i >= diff1_5_size) ? diff1_5_i = 0;
x5 = z5 + diff1_5_c * inp5;

z6 = diff1_6_line[diff1_6_i];
inp6 = delay_6_line[delay_6_i] - t;
inp6 -= diff1_6_c * z6;
diff1_6_line[diff1_6_i] = inp6;
diff1_6_i += 1;
(diff1_6_i >= diff1_6_size) ? diff1_6_i = 0;
x6 = z6 + diff1_6_c * inp6;

z7 = diff1_7_line[diff1_7_i];
inp7 = delay_7_line[delay_7_i] - t;
inp7 -= diff1_7_c * z7;
diff1_7_line[diff1_7_i] = inp7;
diff1_7_i += 1;
(diff1_7_i >= diff1_7_size) ? diff1_7_i = 0;
x7 = z7 + diff1_7_c * inp7;

// Hadamard mixing - NO NORMALIZATION (original doesn't normalize here)
t = x0 - x1; x0 += x1; x1 = t;
t = x2 - x3; x2 += x3; x3 = t;
t = x4 - x5; x4 += x5; x5 = t;
t = x6 - x7; x6 += x7; x7 = t;
t = x0 - x2; x0 += x2; x2 = t;
t = x1 - x3; x1 += x3; x3 = t;
t = x4 - x6; x4 += x6; x6 = t;
t = x5 - x7; x5 += x7; x7 = t;
t = x0 - x4; x0 += x4; x4 = t;
t = x1 - x5; x1 += x5; x5 = t;
t = x2 - x6; x2 += x6; x6 = t;
t = x3 - x7; x3 += x7; x7 = t;

// Output for stereo
g1 += d1;
out_l = g1 * (x1 + x2);
out_r = g1 * (x1 - x2);

// Apply filters and write back to delays - this is where normalization happens
g = sqrt(0.125);

fv0 = g * x0;
filt1_0_slo += filt1_0.wlo * (fv0 - filt1_0_slo) + 1*10^-10;
fv0 += filt1_0.glo * filt1_0_slo;
filt1_0_shi += filt1_0.whi * (fv0 - filt1_0_shi);
fv0 = filt1_0.gmf * filt1_0_shi;
delay_0_line[delay_0_i] = fv0;
delay_0_i += 1;
(delay_0_i >= delay_0_size) ? delay_0_i = 0;

fv1 = g * x1;
filt1_1_slo += filt1_1.wlo * (fv1 - filt1_1_slo) + 1*10^-10;
fv1 += filt1_1.glo * filt1_1_slo;
filt1_1_shi += filt1_1.whi * (fv1 - filt1_1_shi);
fv1 = filt1_1.gmf * filt1_1_shi;
delay_1_line[delay_1_i] = fv1;
delay_1_i += 1;
(delay_1_i >= delay_1_size) ? delay_1_i = 0;

fv2 = g * x2;
filt1_2_slo += filt1_2.wlo * (fv2 - filt1_2_slo) + 1*10^-10;
fv2 += filt1_2.glo * filt1_2_slo;
filt1_2_shi += filt1_2.whi * (fv2 - filt1_2_shi);
fv2 = filt1_2.gmf * filt1_2_shi;
delay_2_line[delay_2_i] = fv2;
delay_2_i += 1;
(delay_2_i >= delay_2_size) ? delay_2_i = 0;

fv3 = g * x3;
filt1_3_slo += filt1_3.wlo * (fv3 - filt1_3_slo) + 1*10^-10;
fv3 += filt1_3.glo * filt1_3_slo;
filt1_3_shi += filt1_3.whi * (fv3 - filt1_3_shi);
fv3 = filt1_3.gmf * filt1_3_shi;
delay_3_line[delay_3_i] = fv3;
delay_3_i += 1;
(delay_3_i >= delay_3_size) ? delay_3_i = 0;

fv4 = g * x4;
filt1_4_slo += filt1_4.wlo * (fv4 - filt1_4_slo) + 1*10^-10;
fv4 += filt1_4.glo * filt1_4_slo;
filt1_4_shi += filt1_4.whi * (fv4 - filt1_4_shi);
fv4 = filt1_4.gmf * filt1_4_shi;
delay_4_line[delay_4_i] = fv4;
delay_4_i += 1;
(delay_4_i >= delay_4_size) ? delay_4_i = 0;

fv5 = g * x5;
filt1_5_slo += filt1_5.wlo * (fv5 - filt1_5_slo) + 1*10^-10;
fv5 += filt1_5.glo * filt1_5_slo;
filt1_5_shi += filt1_5.whi * (fv5 - filt1_5_shi);
fv5 = filt1_5.gmf * filt1_5_shi;
delay_5_line[delay_5_i] = fv5;
delay_5_i += 1;
(delay_5_i >= delay_5_size) ? delay_5_i = 0;

fv6 = g * x6;
filt1_6_slo += filt1_6.wlo * (fv6 - filt1_6_slo) + 1*10^-10;
fv6 += filt1_6.glo * filt1_6_slo;
filt1_6_shi += filt1_6.whi * (fv6 - filt1_6_shi);
fv6 = filt1_6.gmf * filt1_6_shi;
delay_6_line[delay_6_i] = fv6;
delay_6_i += 1;
(delay_6_i >= delay_6_size) ? delay_6_i = 0;

fv7 = g * x7;
filt1_7_slo += filt1_7.wlo * (fv7 - filt1_7_slo) + 1*10^-10;
fv7 += filt1_7.glo * filt1_7_slo;
filt1_7_shi += filt1_7.whi * (fv7 - filt1_7_shi);
fv7 = filt1_7.gmf * filt1_7_shi;
delay_7_line[delay_7_i] = fv7;
delay_7_i += 1;
(delay_7_i >= delay_7_size) ? delay_7_i = 0;

// Apply pareq filters
(pareq1_state != 0) ? (
  c1 = pareq1.c1; c2 = pareq1.c2; gg = pareq1.gg;
  z1 = pareq1_z1_l; z2 = pareq1_z2_l;
  xx = out_l;
  yy = xx - c2 * z2;
  out_l = xx - gg * (z2 + c2 * yy - xx);
  yy -= c1 * z1;
  z2 = z1 + c1 * yy;
  z1 = yy + 1*10^-20;
  pareq1_z1_l = z1; pareq1_z2_l = z2;
);

(pareq1_state != 0) ? (
  c1 = pareq1.c1; c2 = pareq1.c2; gg = pareq1.gg;
  z1 = pareq1_z1_r; z2 = pareq1_z2_r;
  xx = out_r;
  yy = xx - c2 * z2;
  out_r = xx - gg * (z2 + c2 * yy - xx);
  yy -= c1 * z1;
  z2 = z1 + c1 * yy;
  z1 = yy + 1*10^-20;
  pareq1_z1_r = z1; pareq1_z2_r = z2;
);

(pareq2_state != 0) ? (
  c1 = pareq2.c1; c2 = pareq2.c2; gg = pareq2.gg;
  z1 = pareq2_z1_l; z2 = pareq2_z2_l;
  xx = out_l;
  yy = xx - c2 * z2;
  out_l = xx - gg * (z2 + c2 * yy - xx);
  yy -= c1 * z1;
  z2 = z1 + c1 * yy;
  z1 = yy + 1*10^-20;
  pareq2_z1_l = z1; pareq2_z2_l = z2;
);

(pareq2_state != 0) ? (
  c1 = pareq2.c1; c2 = pareq2.c2; gg = pareq2.gg;
  z1 = pareq2_z1_r; z2 = pareq2_z2_r;
  xx = out_r;
  yy = xx - c2 * z2;
  out_r = xx - gg * (z2 + c2 * yy - xx);
  yy -= c1 * z1;
  z2 = z1 + c1 * yy;
  z1 = yy + 1*10^-20;
  pareq2_z1_r = z1; pareq2_z2_r = z2;
);

// Add dry signal back
g0 += d0;
spl0 = out_l + g0 * spl0;
spl1 = out_r + g0 * spl1;
