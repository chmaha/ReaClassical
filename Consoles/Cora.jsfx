NoIndex: true
desc:Cora (ReaClassical.org)
author: chmaha
version: 1.0
Changelog:
  Initial commit
about:
  Uses DSP from airwindows "Interstage" by Chris Johnson
  https://github.com/airwindows/airwindows/tree/master/plugins/LinuxVST/src/Interstage (MIT License)
  JSFX version released under GPLv3 license

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

@init

UINT32_MAX = 4294967295;

fpdL = 1.0; while (fpdL < 16386) (fpdL = rand()*UINT32_MAX);
fpdR = 1.0; while (fpdR < 16386) (fpdR = rand()*UINT32_MAX);

flip = 1;

@slider


@block
overallscale = 1.0;
overallscale /= 44100.0;
overallscale *= srate;

firstStage = 0.381966011250105 / overallscale;
iirAmount = 0.00295 / overallscale;
threshold = 0.381966011250105;

@sample
inputSampleL = spl0;
inputSampleR = spl1;
(abs(inputSampleL)<1.18*10^-23) ? inputSampleL = fpdL * 1.18*10^-17;
(abs(inputSampleR)<1.18*10^-23) ? inputSampleR = fpdR * 1.18*10^-17;

drySampleL = inputSampleL;
drySampleR = inputSampleR;

inputSampleL = (inputSampleL+lastSampleL)*0.5;
inputSampleR = (inputSampleR+lastSampleR)*0.5; 

(flip) ? (
  iirSampleAL = (iirSampleAL * (1 - firstStage)) + (inputSampleL * firstStage); inputSampleL = iirSampleAL;
  iirSampleCL = (iirSampleCL * (1 - iirAmount)) + (inputSampleL * iirAmount); inputSampleL = iirSampleCL;
  iirSampleEL = (iirSampleEL * (1 - iirAmount)) + (inputSampleL * iirAmount); inputSampleL = iirSampleEL;
  inputSampleL = drySampleL - inputSampleL;
  
  (inputSampleL - iirSampleAL > threshold) ? inputSampleL = iirSampleAL + threshold;
  (inputSampleL - iirSampleAL < -threshold) ? inputSampleL = iirSampleAL - threshold;
  
  iirSampleAR = (iirSampleAR * (1 - firstStage)) + (inputSampleR * firstStage); inputSampleR = iirSampleAR;
  iirSampleCR = (iirSampleCR * (1 - iirAmount)) + (inputSampleR * iirAmount); inputSampleR = iirSampleCR;
  iirSampleER = (iirSampleER * (1 - iirAmount)) + (inputSampleR * iirAmount); inputSampleR = iirSampleER;
  inputSampleR = drySampleR - inputSampleR;

  (inputSampleR - iirSampleAR > threshold) ? inputSampleR = iirSampleAR + threshold;
  (inputSampleR - iirSampleAR < -threshold) ? inputSampleR = iirSampleAR - threshold;

) : (
  iirSampleBL = (iirSampleBL * (1 - firstStage)) + (inputSampleL * firstStage); inputSampleL = iirSampleBL;
  iirSampleDL = (iirSampleDL * (1 - iirAmount)) + (inputSampleL * iirAmount); inputSampleL = iirSampleDL;
  iirSampleFL = (iirSampleFL * (1 - iirAmount)) + (inputSampleL * iirAmount); inputSampleL = iirSampleFL;
  inputSampleL = drySampleL - inputSampleL;

  (inputSampleL - iirSampleBL > threshold) ? inputSampleL = iirSampleBL + threshold;
  (inputSampleL - iirSampleBL < -threshold) ? inputSampleL = iirSampleBL - threshold;

  
  iirSampleBR = (iirSampleBR * (1 - firstStage)) + (inputSampleR * firstStage); inputSampleR = iirSampleBR;
  iirSampleDR = (iirSampleDR * (1 - iirAmount)) + (inputSampleR * iirAmount); inputSampleR = iirSampleDR;
  iirSampleFR = (iirSampleFR * (1 - iirAmount)) + (inputSampleR * iirAmount); inputSampleR = iirSampleFR;
  inputSampleR = drySampleR - inputSampleR;

  (inputSampleR - iirSampleBR > threshold) ? inputSampleR = iirSampleBR + threshold;
  (inputSampleR - iirSampleBR < -threshold) ? inputSampleR = iirSampleBR - threshold;

);
flip = !flip;
lastSampleL = inputSampleL;
lastSampleR = inputSampleR;


fpdL ~= fpdL << 13; fpdL ~= fpdL >> 17; fpdL ~= fpdL << 5;
fpdR ~= fpdR << 13; fpdR ~= fpdR >> 17; fpdR ~= fpdR << 5;
(fpdL < 0) ? fpdL += UINT32_MAX;
(fpdR < 0) ? fpdR += UINT32_MAX;

spl0 = inputSampleL;
spl1 = inputSampleR;
