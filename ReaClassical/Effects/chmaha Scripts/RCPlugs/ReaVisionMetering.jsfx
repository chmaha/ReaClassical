Version: 0.99
desc:ReaVision Metering Suite (chmaha)
author: chmaha
about:
  Released under GPLv3 license
  Includes DSP (LGPL) from:
  Cockos Loudness Meter Copyright (C) 2021 and later Cockos Incorporated
  Cockos Bit Meter Copyright (C) 2020 and later Cockos Incorporated
  Spectrograph Meter Copyright (C) 2007 Cockos Incorporated
  https://www.gnu.org/licenses/lgpl-3.0.html
  Includes DSP (MIT License) from:
  ReJJ ReSpectrum Copyright (c) 2021 Justin Johnson
  https://github.com/Justin-Johnson/ReJJ/tree/master/ReSpectrum

slider1:Spectrum_Mode=0<0,5,1{Full,Mid,Side,Mid / Side,Left,Right,Left / Right}>-Spectrum
slider2:Display_Mode=0<0,2,1{Fill,Line,None}>-Display
slider3:Ceiling_Value=0<0,2,1{0dB,20dB,40dB}>-Ceiling
slider4:Floor_Value=0<0,2,1{-90dB,-140dB,-200dB}>-Floor
slider5:Tilt_Value=3<0,5,1{0dB/oct,1.5dB/oct,3dB/oct,4.5dB/oct,6dB/oct}>-Tilt
slider6:Type_Value=1<0,3,1{Hamming,Blackman-Harris,Blackman,Rectangular}>-Type
slider7:Block_Value=2<0,3,1{2048,4096,8192,16384}>-Block Size
slider8:Show_Piano=0<0,1,1{Off,On}>-Show Piano
slider9:Show_Peaks=0<0,1,1{Off,On}>-Show Peaks

import Dependencies/spectrum.jsfx-inc
import Dependencies/svf_filter.jsfx-inc

options:no_meter

@init

gfx_ext_retina  = 1;
ext_nodenorm = 1;
ext_noinit = 1;

//==================================================================================
// Spectrogram init
//==================================================================================

gfx_clear=-1;
windowtype=-1;
over24=1/24;

lrecpos=0;

fftsize=2^10;
lfft=fftsize;
histsize=fftsize*4;
minvol=10^(-180/20*2); // squared
islogmode = 0;
g_logscale=1;
pixels_per_frame = 1;
need_button_refs=1;
rec_write_pos = 0;

//==================================================================================
// Spectrum analyzer init
//==================================================================================

prev_mode_label = "";
spectrum.mem_index = 0;

/*
 * Round number up or down
 */
function round(in) (
  floor(in + 0.5 * sign(in));
);

/*
 * Standard log2
 */
function log2(x) ( 
  log(x) / log(2);
);

/*
 * Return string of integer
 */
function int2str(intIn) local (outStr) (
  strcpy(outStr=#,"");
  sprintf(outStr,"%d",intIn);
  outStr;
);

/*
 * Update the state of any changes
 */
function update_state() local (blocks) (
  spectrum.ceiling = Ceiling_Value == 0 ? 0 : Ceiling_Value == 1 ? 20 : Ceiling_Value == 2 ? 40;
  spectrum.noise_floor = Floor_Value == 0 ? -90 : Floor_Value == 1 ? -140 : Floor_Value == 2 ? -200;
  spectrum.noise_floor = Floor_Value == 0 ? -90 : Floor_Value == 1 ? -140 : Floor_Value == 2 ? -200;
  spectrum.tilt = Tilt_Value == 0 ? 0 : Tilt_Value == 1 ? 1.5 : Tilt_Value == 2 ? 3 : Tilt_Value == 3 ? 4.5 :
                  Tilt_Value == 4 ? 6;

  spectrum.windowtype != Type_Value+1 ? spectrum.set_type(Type_Value+1);

  blocks = (2 ^ (Block_Value+1)) * 1024;

  spectrum.windowsize != blocks ? spectrum.set_block_size(blocks);

  Display_Mode == 0 ? (
    fill_r = 0 / 255;
    fill_g = 153 / 255;
    fill_b = 255 / 255;
    fill_a = 0.5;
    spectrum.set_fill(0, 1);
    spectrum.set_color(0, fill_r, fill_g, fill_b, fill_a);
    fill_r =  0 / 255;
    fill_g = 255 / 255;
    fill_b = 255 / 255;
    fill_a = 0.5;
    spectrum.set_fill(1, 1); 
    spectrum.set_color(1, fill_r, fill_g, fill_b, fill_a);
  ) : Display_Mode == 1 ? (
    line_a=1.0;
    line_r = 0 / 255; line_g = 153 / 255; line_b = 255 / 255;;
    spectrum.set_fill(0, 0);
    spectrum.set_color(0, line_r, line_g, line_b, line_a);
    line_r = 253 / 255; line_g = 185 / 255; line_b = 21 / 255;;
    spectrum.set_fill(1, 0);
    spectrum.set_color(1, line_r, line_g, line_b, line_a);
  );
);

/*
 * Draw a crosshair where the mouse is
 */
function draw_mouse_crosshair() (
  mouse_x >= 0 && mouse_x > gfx_w/2 && mouse_y >=0 && mouse_y < gfx_h/2-16 ? (
    gfx_set(1.0, 1.0, 1.0, 0.3);
    gfx_line(gfx_w/2,mouse_y,gfx_w,mouse_y,1);
    gfx_line(mouse_x,0,mouse_x,gfx_h/2-16,1);
  );
);

/*
 * Draw a round cornered rectangle
 */
function draw_filled_rect(x, y, w, h, rad, alias) ( 
    gfx_circle(x+rad, y+rad, rad, 1, alias);
    gfx_circle(x+w-rad-1, y+rad, rad, 1, alias);
    gfx_circle(x+w-rad-1, y+h-rad-1, rad, 1, alias);
    gfx_circle(x+rad, y+h-rad-1, rad, 1, alias);

    gfx_rect(x, y+rad, rad*2, h-rad*2, alias);
    gfx_rect(x+w-rad*2, y+rad, rad*2, h-rad*2, alias);
    gfx_rect(x+rad, y, w-rad*2, rad*2, alias);
    gfx_rect(x+rad, y+h-rad*2, w-rad*2, rad*2, alias);

    gfx_rect(x+rad, y+rad, w-rad*2, h-rad*2, alias);
);

/*
 * Draw the info panel showing frequency, note, cent and dB
 */
function draw_info_panel(note_select)
  local(read_freq, read_amp, q, band, C0, semi, octave, note, cent, keys, nn, note_freq, centstr, width, xpos, xpos2, ypos)
 (
  mouse_x >= gfx_w/2 && mouse_x < gfx_w && mouse_y >= 0 && mouse_y < gfx_h/2 ? (
    gfx_set(0, 0.5, 1);
    read_freq = note_select == 0 ? spectrum.x_to_freq(mouse_x) : note_select;
    read_amp = spectrum.y_to_db(mouse_y);
    
    // Position in lower corner of upper right quadrant
    width = 130;
    gfx_ext_retina != 2 ? width -= 40;
    
    xpos = gfx_w/2 + 10;
    xpos2 = xpos + 55;
    gfx_ext_retina != 2 ? xpos2 -= 15;
    ypos = 20;  // Bottom of upper half, minus panel height and margin
    
    gfx_x = xpos;
    gfx_y = ypos;
    
    // Black background with transparency
    gfx_r = 0; gfx_g = 0; gfx_b = 0; gfx_a = 0.7;
    gfx_rect(gfx_x-5, gfx_y-5, width, gfx_texth*4, 1);
    
    // Blue border with transparency
    gfx_r = (0 / 255); gfx_g = (153 / 255); gfx_b = (255 / 255); gfx_a = 0.5;
    gfx_rect(gfx_x-10, gfx_y-10, width, gfx_texth*4, 1);
    
    // Light blue text
    gfx_r = 114 / 255; gfx_g = 215 / 255; gfx_b = 253 / 255; gfx_a = 1.0;
    gfx_ext_retina != 2 ? gfx_y -= 8;
    
    read_freq < 100 ? ( gfx_drawstr(sprintf(#,"%.1f Hz", read_freq)) ) :
      (read_freq < 1000 ? ( gfx_drawstr(sprintf(#,"%.0f Hz", read_freq)) ) : ( 
        (read_freq < 10000 ? ( gfx_drawstr(sprintf(#,"%.2f kHz", read_freq/1000)) ) : ( 
          gfx_drawstr(sprintf(#,"%.1f kHz", read_freq/1000));
        )
      )
    ));
    
    // 440Hz is A4, get C0 as offset from that
    C0 = 440 * pow(2, -4.75);
    // Get seminotes (note number), octave and note within octave
    semi = round(12 * log2(read_freq / C0));
    octave = floor(semi / 12);
    note = (semi % 12);
    // Calculate cents
    note_freq = C0 * 2.71828 ^ (0.0577623 * semi);
    cent = floor(1200 * log2(read_freq / note_freq));
    // The above math goes a bit screwy for our -1 lowest octave.
    // We get a kind of inverse reflection.  This fixes it up.
    octave == -1 ? (
      note = (13 - (-(semi))) % 12;
      cent = -(99 - cent);
    );
    // Display it all
    keys="CCDDEFFGGAAB";
    strcpy_substr(nn=#,keys,note,1);
    note==1 || note==3 || note==6 || note==8 || note==10 ? strcat(nn,"#");
    strcat(nn, int2str(octave));
    cent < 0 ? strcpy(centstr=#,"-") : strcpy(centstr=#,"+");
    abs(cent) <= 9 ? strcat(centstr, "0");
    strcat(centstr, sprintf(#, "%d", abs(cent)));
    
    gfx_x = xpos;
    gfx_y += gfx_texth+2;
    gfx_drawstr(nn);
    gfx_x = xpos2;
    gfx_drawstr(centstr);
    gfx_x = xpos;
    gfx_y += gfx_texth+2;
    gfx_drawstr(sprintf(#,"%.1f DB", read_amp));
  );
);

/*
 * Draw the listener boundaries and set the Q for the bandpass filter
 */
function draw_listen_helper()
  local (mouse_spec, lread_freq, rread_freq, lfreq, rfreq, lx, rx, c0, lnsemi, lnoct, rnsemi, rnoct, oct)
(
  gfx_r = 114 / 255; gfx_g = 215 / 255; gfx_b = 253 / 255;

  listen_freq = spectrum.x_to_freq(mouse_x);

  mouse_spec = (mouse_x - spectrum.left_margin) / (gfx_w - spectrum.left_margin - spectrum.right_margin);

  lread_freq = spectrum.min_freq * exp(spectrum.freq_log_max * (mouse_spec - listen_width));
  rread_freq = spectrum.min_freq * exp(spectrum.freq_log_max * (mouse_spec + listen_width));

  lfreq = lread_freq;
  rfreq = rread_freq;

  lx = spectrum.freq_to_x(lfreq);
  rx = spectrum.freq_to_x(rfreq);

  c0 = 440.0 * 2.0 ^ (-57.0 / 12.0);    //C0 is 57 semitones below A4 (440 Hz)

  lnsemi = 12.0 * log(lfreq / c0) / log(2.0);
  lnoct = lnsemi / 12;           //Scientific pitch notation octave number

  rnsemi = 12.0 * log(rfreq / c0) / log(2.0);
  rnoct = rnsemi / 12;           //Scientific pitch notation octave number

  oct = rnoct - lnoct;

  listen_q = filter.svf_bwtoq(oct);

  gfx_a = 1.0;
  gfx_line(lx, 0, lx, gfx_h - gfx_texth+2);
  gfx_line(rx, 0, rx, gfx_h - gfx_texth+2);

  gfx_a = 0.8;
  gfx_line(lx-2, 0, lx-2, gfx_h - gfx_texth+2);
  gfx_line(rx+2, 0, rx+2, gfx_h - gfx_texth+2);

  gfx_a = 0.5;
  gfx_line(lx-4, 0, lx-4, gfx_h - gfx_texth+2);
  gfx_line(rx+4, 0, rx+4, gfx_h - gfx_texth+2);
);

/*
 * Initialize the mode button
 */
function init_mode_button(xpos, ypos, buttonwidth) instance (x, y, width, label) (
  x = xpos;
  y = ypos;
  width = buttonwidth;
  label = "Full";
);

/*
 * Initialize the channel button (appears when in Mid/Side or Left-Right mode)
 */
function init_channel_button(xpos, ypos, buttonwidth) instance (x, y, width, label) (
  x = xpos;
  y = ypos;
  width = buttonwidth;
  label = "Mid+Side";
);

/*
 * Draw the mode button
 */
function draw_mode_button() instance (x, y, width, label, height) local(w, h, a) ( 
  mouse_x >= gfx_w/2 && mouse_x < gfx_w && mouse_y >= 0 && mouse_y < gfx_h/2 ? (
    gfx_a = 1;
    gfx_measurestr(label, w, h);
    height = h + 8;
    mouse_x >= x && mouse_x <= x+width && mouse_y >= y && mouse_y <= y + height ? ( 
      gfx_r = (0 / 255);
      gfx_g = (153 / 255);
      gfx_b = (255 / 255);
      gfx_a = 0.6;
    ) : (
      gfx_r = (0 / 255);
      gfx_g = (153 / 255);
      gfx_b = (255 / 255);
      gfx_a = 0.4;
    );
    gfx_rect(x, y, width, h+9, 1);
    
    gfx_r = (114 / 255);
    gfx_g = (215 / 255);
    gfx_b = (253 / 255);
    gfx_a = 1;
    gfx_x = x + (width / 2) - (w / 2);
    gfx_y = y + 4;
    gfx_drawstr(label);
  );
);

/*
 * Draw the channel button (only visible in Mid/Side or Left-Right mode)
 */
function draw_channel_button() instance (x, y, width, label, height) local(w, h, a) ( 
  mouse_x >= gfx_w/2 && mouse_x < gfx_w && mouse_y >= 0 && mouse_y < gfx_h/2 ? (
    gfx_a = 1;
    gfx_measurestr(label, w, h);
    height = h + 8;
    mouse_x >= x && mouse_x <= x+width && mouse_y >= y && mouse_y <= y + height ? ( 
      gfx_r = (0 / 255);
      gfx_g = (153 / 255);
      gfx_b = (255 / 255);
      gfx_a = 0.6;
    ) : (
      gfx_r = (0 / 255);
      gfx_g = (153 / 255);
      gfx_b = (255 / 255);
      gfx_a = 0.4;
    );
    gfx_rect(x, y, width, h+9, 1);
    
    gfx_r = (114 / 255);
    gfx_g = (215 / 255);
    gfx_b = (253 / 255);
    gfx_a = 1;
    gfx_x = x + (width / 2) - (w / 2);
    gfx_y = y + 4;
    gfx_drawstr(label);
  );
);

/*
 * Handle clicking the mode button (Full -> Mid/Side -> Left-Right -> Full)
 */
function handle_mode_button() instance (x, y, width, label, pressed, height)
  local ()
(
  mouse_cap & 1 && !pressed ? (
    mouse_x >= x && mouse_x <= x+width && mouse_y >= y && mouse_y <= y + height ? ( 
      pressed = 1;
      
      // Cycle through modes
      strcmp(label, "Full") == 0 ? (
        label = "Mid/Side";
        Spectrum_Mode = 3;  // Default to Mid+Side when entering Mid/Side mode
      ) : strcmp(label, "Mid/Side") == 0 ? (
        label = "Left/Right";
        Spectrum_Mode = 6;  // Default to Left+Right when entering Left-Right mode
      ) : strcmp(label, "Left/Right") == 0 ? (
        label = "Full";
        Spectrum_Mode = 0;
      );
    spectrum.reset_buffers()
    ) : pressed = 0;
  ) : ( 
    !(mouse_cap & 1) ? pressed = 0;
  );
);

/*
 * Handle clicking the channel button (cycles through options based on current mode)
 */
function handle_channel_button(mode_label) instance (x, y, width, label, pressed, height)
  local ()
(
  mouse_cap & 1 && !pressed ? (
    mouse_x >= x && mouse_x <= x+width && mouse_y >= y && mouse_y <= y + height ? ( 
      pressed = 1;
      
      // Cycle based on current mode
      strcmp(mode_label, "Mid/Side") == 0 ? (
        // Mid/Side mode: Mid+Side -> Mid -> Side -> Mid+Side
        strcmp(label, "Mid+Side") == 0 ? (
          label = "Mid";
          Spectrum_Mode = 1;
        ) : strcmp(label, "Mid") == 0 ? (
          label = "Side";
          Spectrum_Mode = 2;
        ) : strcmp(label, "Side") == 0 ? (
          label = "Mid+Side";
          Spectrum_Mode = 3;
        );
      ) : strcmp(mode_label, "Left/Right") == 0 ? (
        // Left-Right mode: Left+Right -> Left -> Right -> Left+Right
        strcmp(label, "Left+Right") == 0 ? (
          label = "Left";
          Spectrum_Mode = 4;
        ) : strcmp(label, "Left") == 0 ? (
          label = "Right";
          Spectrum_Mode = 5;
        ) : strcmp(label, "Right") == 0 ? (
          label = "Left+Right";
          Spectrum_Mode = 6;
        );
      );
    spectrum.reset_buffers()
    ) : pressed = 0;
  ) : ( 
    !(mouse_cap & 1) ? pressed = 0;
  );
);

/*
 * Initialise the peaks button
 */
function init_peak_button(xpos, ypos, buttonwidth) instance (x, y, width, label) (
  x = xpos;
  y = ypos;
  width = buttonwidth;
  label = "Peaks";
);

/*
 * Draw the peaks toggle button
 */
function draw_peak_button() instance (x, y, width, menutext, label, pressed, height, label) local(w, h, a) ( 
  mouse_x >= gfx_w/2 && mouse_x < gfx_w && mouse_y >= 0 && mouse_y < gfx_h/2 ? (
  gfx_a = 1;
  gfx_measurestr(label, w, h);
  height = h + 8;
  mouse_x >= x && mouse_x <= x+width && mouse_y >= y && mouse_y <= y + height ? ( 
    gfx_r = (0 / 255);
    gfx_g = (153 / 255);
    gfx_b = (255 / 255);
    gfx_a = 0.6;
  ) : (
    Show_Peaks ? a = 0.6 : a = 0.4;
    gfx_r = (0 / 255);
    gfx_g = (153 / 255);
    gfx_b = (255 / 255);
    gfx_a = a;
  );
  gfx_rect(x, y, width, h+9, 1);
  
  Show_Peaks ? (
    gfx_r = (114 / 255);
    gfx_g = (215 / 255);
    gfx_b = (253 / 255);
  ) : ( 
    gfx_r = (114 / 300);
    gfx_g = (215 / 300);
    gfx_b = (253 / 300);    
  );
  gfx_a = 1;
  gfx_x = x + (width / 2) - (w / 2);
  gfx_y = y + 4;
  gfx_drawstr(label);
  );
);

/*
 * Handle clicking the peaks button
 */
function handle_peak_button() instance (x, y, width, label, pressed, height, label)
  local (last_clicked_item)
(
  last_clicked_item = 0;
  mouse_cap & 1 && !pressed ? (
    mouse_x >= x && mouse_x <= x+width && mouse_y >= y && mouse_y <= y + height ? ( 
      pressed = 1;

      Show_Peaks = Show_Peaks ? Show_Peaks = 0 : 1;

      spectrum.set_show_peaks(Show_Peaks);

    ) : pressed = 0;
  ) : ( 
    !(mouse_cap & 1) ? pressed = 0;
  );
);


/*
 * Set global state vars
 */

do_listen = 0;
listen_width = 0.10;

filter.svf_set_sample_rate(srate);

gfx_ext_retina == 2 ? (
  peaks.init_peak_button(gfx_w - 150, 10, 100);
  mode_button.init_mode_button(gfx_w - 400, 10, 120);
  channel_button.init_channel_button(gfx_w - 280, 10, 120);
) : ( 
  peaks.init_peak_button(gfx_w - 100, 10, 60);
  mode_button.init_mode_button(gfx_w - 280, 10, 80);
  channel_button.init_channel_button(gfx_w - 200, 10, 80);
);

spectrum.set_show_peaks(Show_Peaks);

//==================================================================================
// Loudness, Gonio, Correl inits
//==================================================================================

<?
  nch = max(max_nch,64); // maximum channel count
  sinc_sz = 32; // true peak interpolation size
  use_mem_sinc = sinc_sz>32;

  printf("sinc_sz = %d;\n",sinc_sz);

 function do_all_channels(fmt) local(p x c) global(nch) (
   p=x=0;
   while (x < nch) (
     p+=1;
     x>0 ? printf("num_ch > %d ? ( ",x);
     c = x>=24 ? 8 : x>=8 ? 4 : 2;
     loop(c, printf(fmt,x,x); x+=1);
     printf("\n");
   );
   loop(p-1,printf(")"));
 );
?>

// Constants
WANT_INTEGRATED_ALWAYS=0;
PEAK_METER_DECAY=0.150;
LOUD_METER_UPDATE=0.100;
LOUD_METER_SPEED=0.075;
NUM_BINS=1024;
BINS_PER_DB=10;
DB_PER_BIN=1/BINS_PER_DB;
cfg_peak = 1;
ext_noinit=1;
gfx_clear=-1;
ext_nodenorm=1;
cfg_reinit=1;
attackms=50.0;
decayms=300.0;
mv=pow(2,63);

// Memory allocation
function alloc(sz) (
  memset((alloc.top += sz) - sz, 0, sz);
);

function alloc(sz) global()
(
  memset((this.top+=sz)-sz,0,sz);
);

// sinc filter for true peak
function sinc_gen_val() global(srate sinc_sz) local(sincpos windowpos) instance(slice_pos) (
  windowpos = (2.0 * $pi / sinc_sz) * slice_pos;
  sincpos = $pi * (slice_pos - sinc_sz * .5);
  slice_pos += 1;
  (0.53836 - cos(windowpos)*0.46164) * sin(sincpos) / sincpos;
);

function sinc_gen_slice(cs, o*) instance(sinc_gen_val slice_pos) local(x) global(sinc_sz) (
  slice_pos = cs;
<?
  use_mem_sinc ? (
    printf("o.v = alloc(sinc_sz);  loop(x=0;sinc_sz, o.v[x] = sinc_gen_val(); x+=1); ");
  ) : (
    loop(x=0;sinc_sz, printf("o.v%02d = sinc_gen_val();%s",x,(x&3)==3?"\n": " "); x += 1)
  );
?>
);

function sinc_init() global(srate) instance(sinc_gen_slice) (
  sinc_gen_slice(srate < 96000 ? .25 : .5,this.s1);
  srate < 96000 ? (
    sinc_gen_slice(.5, this.s2);
    sinc_gen_slice(.75, this.s3);
  );
);

<?
 function emit_sinc(hist, t) (
   use_mem_sinc ? (
    printf("abs(mem_multiply_sum(%s.v,%s.h,sinc_sz))",t,hist);
   ) : (
     printf("abs(");
     loop(x=0;sinc_sz, printf("%s.h%02d * %s.v%02d%s",hist,x,t,x,x==sinc_sz-1?"":(x&3)==3?" +\n":" + "); x+=1);
     printf(")");
   );
 );
?>

function init(chidx)
(
  this.chan=chidx;
  this.wt = chidx < 3 || num_ch < 6 ? 1 : chidx == 3 ? 0 : sqrt(2);
  this.f1p1=this.f1p2=this.f2p1=this.f2p2=0;
  this.pkval=this.hipkval=this.clips=0;
  this.ch_lufs_sum=this.ch_rms_sum=0;
  <?
    use_mem_sinc ? (
      printf("this.h = alloc(sinc_sz);\n");
    ) : (
      loop(x=0;sinc_sz, printf("this.h%02d =%s",x,x==sinc_sz-1 ? " 0" : (x&7)==7 ? "\n" : " "); x+=1);
    );
  ?>
);

function decay()
(
  this.pkval *= pk_decay;
);

function copypks() global(pk hipk clip_cnt) (
  pk[this.chan] = this.pkval;
  hipk[this.chan] = this.hipkval;
  clip_cnt[this.chan] = this.clips;
);

function proc(lspl)
  local(pspl f1p0 f2p0)
  instance(wt ch_rms_sum ch_lufs_sum pkval hipkval clips
           f1p1 f1p2 f2p1 f2p2)
  global(f1a1 f1a2 f1b0 f1b1 f1b2
         f2a1 f2a2 f2b0 f2b1 f2b2
         srate cfg_peak
         lval rval win_pos global_peak sinc_sz
         sinc.s1* sinc.s2* sinc.s3*
         )
(
  cfg_peak == 1 || cfg_peak == 2 ? (
    <?
      use_mem_sinc ? (
        printf("mem_insert_shuffle(this.h, sinc_sz, lspl);");
      ) : (
        loop(x=sinc_sz-1;sinc_sz-1, printf("this.h%02d = this.h%02d;%s",x,x-1, (x&3)==0 ? "\n" : " "); x-= 1; );
        printf(" this.h00 = lspl;");
      );
    ?>
    pspl = max(
        abs(this.h<? printf(use_mem_sinc ? "[%d]" : "%02d",sinc_sz/2) ?> ),
        <? emit_sinc("this","sinc.s1") ?>
       );
    srate < 96000 ? pspl = max(pspl,max( <? emit_sinc("this","sinc.s2") ?>,  <? emit_sinc("this","sinc.s3") ?>));
  ) :
  cfg_peak == 3 || cfg_peak == 4 ? (
    pspl=abs(lspl);
  );
  cfg_peak ? (
    pspl > pkval ? (
      pkval=pspl;
      pspl > hipkval ? (
        hipkval=pspl;
        global_peak = max(global_peak,pspl);
      );
    );
    pspl > 1.0 ? clips += 1;
  );

  win_pos == 0 ? ch_rms_sum=ch_lufs_sum=0;

  rval += (ch_rms_sum += lspl*lspl);

  lspl *= wt;

  f1p0=lspl-f1a1*f1p1-f1a2*f1p2;
  lspl=f1b0*f1p0+f1b1*f1p1+f1b2*f1p2;
  f1p2=f1p1;
  f1p1=f1p0;

  f2p0=lspl-f2a1*f2p1-f2a2*f2p2;
  lspl=f2b0*f2p0+f2b1*f2p1+f2b2*f2p2;
  f2p2=f2p1;
  f2p1=f2p0;

  lval += (ch_lufs_sum += lspl*lspl);
);

function init_lufs_filters()
  local(Vh Vb db f0 Q K a0)
  global(f1a1 f1a2 f1b0 f1b1 f1b2
         f2a1 f2a2 f2b0 f2b1 f2b2 srate)
(
  // f1,f2 could be combined into a 5th order filter

  db=3.999843853973347;
  f0=1681.974450955533;
  Q=0.7071752369554196;
  K=tan($pi*f0/srate);
  Vh=pow(10, db/20);
  Vb=pow(Vh, 0.4996667741545416);
  a0=1+K/Q+K*K;
  f1a1=2*(K*K-1)/a0;
  f1a2=(1-K/Q+K*K)/a0;
  f1b0=(Vh+Vb*K/Q+K*K)/a0;
  f1b1=2*(K*K-Vh)/a0;
  f1b2=(Vh-Vb*K/Q+K*K)/a0;

  f0=38.13547087602444;
  Q=0.5003270373238773;
  K=tan($pi*f0/srate);
  f2a1=2*(K*K-1)/(1+K/Q+K*K);
  f2a2=(1-K/Q+K*K)/(1+K/Q+K*K);
  f2b0=1;
  f2b1=-2;
  f2b2=1;
);

spectrum.init();
spectrum_mem_end = spectrum.mem_index;
alloc.top = spectrum_mem_end;
recpos = alloc(histsize);
fftworkspace = alloc(fftsize*2);
window = alloc(fftsize);

function Reset() (
  init_lufs_filters();
  alloc.top = window+fftworkspace + fftsize*2;
  pk=alloc(<?printf("%d",nch)?>);
  hipk=alloc(<?printf("%d",nch)?>);
  clip_cnt=alloc(<?printf("%d",nch)?>);
  sinc.sinc_init();

  m_win_cnt=0.4/LOUD_METER_UPDATE;
  s_win_cnt=3/LOUD_METER_UPDATE;

  win_pos=0;
  win_cnt=0;
  win_len=(LOUD_METER_UPDATE*srate)|0;
  i_win_len=1/(m_win_cnt*win_len);
  i_win_len2=1/(s_win_cnt*win_len);

  rms_m_sum=0;
  rms_m_db=-100;
  rms_m_db_max=-100;
  rms_i_sum=0;
  rms_i_sum_cnt=0;
  rms_i_db=-100;

  lufs_m_sum=0;
  lufs_m_sum_max=0;
  lufs_m_db=-100;
  lufs_s_sum=0;
  lufs_s_sum_max=0;
  lufs_s_db=-100;
  lufs_a_sum=0;
  lufs_a_sum_cnt=0;
  lufs_b_sum=0;
  lufs_b_sum_cnt=0;
  lra_db_diff = 0;
  lra_db_hi = lra_db_lo = lufs_i_db = lufs_m_db = lufs_s_db = -100;

  last_t=0;
  th_lufs_i=th_lufs_s=th_lufs_m=th_rms_i=th_rms_m=0;

  cur_buf=0;
  cur_buf2=0;
  rms_buf=alloc(m_win_cnt);
  lufs_buf=alloc(m_win_cnt);
  lufs_buf2=alloc(s_win_cnt);
  lufs_a_hist=alloc(2*NUM_BINS);
  lufs_b_hist=alloc(NUM_BINS);
  db_hist=alloc(75);
  db_hist_max=0;

  global_peak = 0;

  <? do_all_channels("ch%d.init(%d); "); ?>;

  gonio_size = 4800;
  gonio_buffer_L = alloc(gonio_size);
  gonio_buffer_R = alloc(gonio_size);
  gonio_pos = 0;

  corr_LR_sum = 0;
  corr_LL_sum = 0;
  corr_RR_sum = 0;
  corr_count = 0;

bitbuf_len = 64;

bbuf = alloc(bitbuf_len);
tbuf = alloc(bitbuf_len);

memset(bbuf, 0, bitbuf_len);
memset(tbuf, 0, bitbuf_len);

);

Reset();

@slider

update_state();

@block

// Detect transport restart
!(last_play_state & 1) && (play_state & 1) ? (
  need_clear_spectro = 1;
);
last_play_state = play_state;

ifftsize=1/fftsize;

(num_ch > 0 && num_ch != last_nch) || srate != last_sr ? Reset();
last_nch = num_ch;
last_sr = srate;

cfg_reinit && (play_state&1) ? (
  abs(play_position-last_play_pos) > 0.1 ? Reset();
  last_play_pos=play_position+samplesblock/srate;
);

pk_decay=pow(0.5, samplesblock/srate/PEAK_METER_DECAY);

<? do_all_channels("ch%d.decay(); "); ?>;

dv=1.0/(sqrt(num_ch)*samplesblock);
attack=exp(-log(2.0)*samplesblock/(srate*attackms*0.001));
decay=exp(-log(2.0)*samplesblock/(srate*decayms*0.001));

bat=0;
loop
(
  64,
  bbuf[bat] *= decay;
  v=sqrt(min(tbuf[bat],1.0));
  v > bbuf[bat] ?
  (
    bbuf[bat]=bbuf[bat]*attack+v*(1.0-attack);
  ) : (
    bbuf[bat] < 0.001 ? bbuf[bat]=0.0;
  );
  tbuf[bat]=0.0;
  bat += 1;
);

@sample

// Mid/Side encode
mid = (spl0 + spl1) * 0.5;
side = (spl0 - spl1) * 0.5;

// Feed the correct buffers depending on spectrum modes
Spectrum_Mode == 0 ? spectrum.sample0(spl0 + spl1) :
Spectrum_Mode == 1 ? spectrum.sample0(mid) :
Spectrum_Mode == 2 ? spectrum.sample0(side) :
Spectrum_Mode == 3 ? (spectrum.sample0(mid); spectrum.sample1(side)) :
Spectrum_Mode == 4 ? spectrum.sample0(spl0) :
Spectrum_Mode == 5 ? spectrum.sample0(spl1) :
Spectrum_Mode == 6 ? (spectrum.sample0(spl0); spectrum.sample1(spl1));

// // Filter if we're in listen mode
// do_listen ? (
//   mono = 0.5 * (spl0 + spl1);
//   filter.svf_bp2(listen_freq, listen_q);
//   spl0 = spl1 = filter.svf_svf0(mono); 
// );

rval=lval=0;

<? do_all_channels("ch%d.proc(spl%d); "); ?>;

(win_pos += 1) >= win_len ? (
  win_pos=0;
  win_cnt += 1;

  prev_rval=rms_buf[cur_buf];
  rms_buf[cur_buf]=rval;

  prev_lval=lufs_buf[cur_buf];
  lufs_buf[cur_buf]=lval;

  prev_lval2=lufs_buf2[cur_buf2];
  lufs_buf2[cur_buf2]=lval;

  (cur_buf += 1) >= m_win_cnt ? cur_buf=0;
  (cur_buf2 += 1) >= s_win_cnt ? cur_buf2=0;

  rms_m_sum += (rval-prev_rval)*i_win_len;
  lufs_m_sum += (lval-prev_lval)*i_win_len;
  lufs_s_sum += (lval-prev_lval2)*i_win_len2;

  WANT_INTEGRATED_ALWAYS || (play_state&1) ? (
    rms_i_sum += rms_m_sum;
    rms_i_sum_cnt += 1;
    rms_i_sum > 0 && rms_i_sum_cnt >= m_win_cnt ? (
      rms_i_db=log(rms_i_sum/rms_i_sum_cnt)*10/log(10);
    ) : (
      rms_i_db=-100;
    );
  );

  rms_m_sum > 0 && win_cnt >= m_win_cnt ? (
    rms_m_db=log(rms_m_sum)*10/log(10);
    rms_m_db > rms_m_db_max ? rms_m_db_max=rms_m_db;
  ) : (
    rms_m_db=-100;
  );

  lufs_m_sum > 0 && win_cnt >= m_win_cnt ? (
    lufs_m_sum > lufs_m_sum_max ? lufs_m_sum_max=lufs_m_sum;
    lufs_m_db=-0.691+log(lufs_m_sum)*10/log(10);

    a = WANT_INTEGRATED_ALWAYS || (play_state&1) ? ((lufs_m_db+70)*BINS_PER_DB)|0 : -1;
    a >= 0 ? (
      a >= NUM_BINS ? a=NUM_BINS-1;
      lufs_a_sum += lufs_m_sum;
      lufs_a_sum_cnt += 1;
      lufs_a_hist[2*a] += 1;
      lufs_a_hist[2*a+1] += lufs_m_sum;
      db_hist_max = max(db_hist_max,db_hist[min(a*DB_PER_BIN,74)] += 1);

      lufs_a_db=-0.691+log(lufs_a_sum/lufs_a_sum_cnt)*10/log(10);
      lufs_a_gate=((lufs_a_db-10+70)*BINS_PER_DB)|0;
      lufs_i_sum=0;
      lufs_i_cnt=0;
      bin=max(lufs_a_gate,0);
      loop(NUM_BINS-bin,
        lufs_i_cnt += lufs_a_hist[2*bin];
        lufs_i_sum += lufs_a_hist[2*bin+1];
        bin += 1;
      );
      lufs_i_db=lufs_i_sum > 0 ? -0.691+log(lufs_i_sum/lufs_i_cnt)*10/log(10) : -100;
    );
  ) : (
    lufs_m_db=-100;
  );

  lufs_s_sum > 0 && win_cnt >= s_win_cnt ? (
    lufs_s_sum > lufs_s_sum_max ? lufs_s_sum_max=lufs_s_sum;
    lufs_s_db=-0.691+log(lufs_s_sum)*10/log(10);

    b = WANT_INTEGRATED_ALWAYS || (play_state&1) ? ((lufs_s_db+70)*BINS_PER_DB)|0 : -1;
    b >= 0 ? (
      b >= NUM_BINS ? b=NUM_BINS-1;
      lufs_b_sum += lufs_s_sum;
      lufs_b_sum_cnt += 1;
      lufs_b_hist[b] += 1;

      lufs_b_db=-0.691+log(lufs_b_sum/lufs_b_sum_cnt)*10/log(10);
      lufs_b_gate=((lufs_b_db-20+70)*BINS_PER_DB)|0;

      lra_cnt=0;
      bin=max(lufs_b_gate,0);
      loop(NUM_BINS-bin,
        lra_cnt += lufs_b_hist[bin];
        bin += 1;
      );
      lra_cnt >= 20 ? (
        lra_cnt_lo=lra_cnt_hi=0;
        bin=lufs_b_gate;
        while(bin < NUM_BINS && lra_cnt_lo < lra_cnt*0.10)
        (
          lra_cnt_lo += lufs_b_hist[bin];
          bin += 1;
        );
        bin_lo=bin-1;
        bin=NUM_BINS-1;
        while(bin >= lufs_b_gate && lra_cnt_hi < lra_cnt*0.05)
        (
          lra_cnt_hi += lufs_b_hist[bin];
          bin -= 1;
        );
        bin_hi=bin+1;
        lra_db_lo=bin_lo*DB_PER_BIN-70;
        lra_db_hi=bin_hi*DB_PER_BIN-70;
        lra_db_diff = lra_db_hi-lra_db_lo;
      );
    );
  ) : (
    lufs_s_db=-100;
  );
);

tp_l_db = hipk[0] > 0 ? 20.0 * log(hipk[0]) / log(10) : -200.0;
tp_r_db = num_ch > 1 && hipk[1] > 0 ? 20.0 * log(hipk[1]) / log(10) : -200.0;

// Phase correlation
corr_LR_sum += spl0 * spl1;
corr_LL_sum += spl0 * spl0;
corr_RR_sum += spl1 * spl1;

(corr_count += 1) > 50000 ? (
    corr_LR_sum *= 0.5;
    corr_LL_sum *= 0.5;
    corr_RR_sum *= 0.5;
    corr_count = 25000;
);

den = sqrt(corr_LL_sum * corr_RR_sum);
phase_correlation = den > 0 ? (corr_LR_sum / den) : 0;
phase_correlation = min(max(phase_correlation, -1), 1);

// Goniometer
gonio_buffer_L[gonio_pos] = spl0;
gonio_buffer_R[gonio_pos] = spl1;
gonio_pos += 1;
gonio_pos >= gonio_size ? gonio_pos = 0;

c=0;
loop
(
  num_ch,
  v=abs(spl(c))*mv;
  bat=0;
  v > 0.0 ? loop
  (
    64,
    nv=floor(v*0.5);
    nv*2.0 != v ? tbuf[bat] += dv;
    v=nv;
    bat += 1;
  );
  c += 1;
);

recpos[rec_write_pos]=(spl0+spl1);
rec_write_pos+=1;
reccnt+=1;
rec_write_pos >= histsize ? rec_write_pos=0;

//==================================================================================
// gfx section start
//==================================================================================

@gfx 1280 625
gfx_w != 1280 || gfx_h != 625 ? (
  gfx_w = 1280;
  gfx_h = 625;
);

<? do_all_channels("ch%d.copypks(); ");?>;

t=time_precise();
speed = last_t ? 1.0-pow(0.5, (t-last_t)/LOUD_METER_SPEED) : 1;
last_t=t;

nch = cfg_mono ? 1 : max(num_ch,2);

// Fade for goniometer trail
gfx_r = 0; gfx_g = 0; gfx_b = 0;
gfx_a = 0.025;
gfx_x = 0; gfx_y = 250;
gfx_rectto(gfx_w/4, 500);
gfx_a = 1;

//Clear text areas
gfx_r = 0; gfx_g = 0; gfx_b = 0;
gfx_rect(0, 0, gfx_w/2, 260);
gfx_rect(335, 295, 225, 30); 
gfx_r = 0; gfx_g = 0; gfx_b = 0;
gfx_rect(320, 385, 260, 20);
gfx_rect(gfx_w/2-50, 0, gfx_w, gfx_h/2);
gfx_rect(0, 455, gfx_w/2-50, gfx_h);

//Title
gfx_r = 0; gfx_g = 0.6; gfx_b = 1;
gfx_x = 20; gfx_y = 10;
gfx_setfont(1, "Arial", 18);
gfx_drawstr("ReaVision Metering Suite");

gfx_setfont(1, "Arial", 14);

//LUFS Display
gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = 20; gfx_y = 50;
gfx_drawstr("LUFS Integrated:");
gfx_x = 180; gfx_y = 50;
sprintf(#str, "%.1f LUFS", lufs_i_db);
lufs_i_db > -100 ? (
gfx_drawstr(#str);
) : (
gfx_drawstr("---")
);

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = 20; gfx_y = 80;
gfx_drawstr("LUFS Short-term:");
gfx_x = 180; gfx_y = 80;
sprintf(#str, "%.1f LUFS", lufs_s_db);
lufs_s_db > -100 ? (
gfx_drawstr(#str);
) : (
gfx_drawstr("---")
);
gfx_x = 300; gfx_y = 80;
gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
sprintf(#str, "(max: %.1f)", -0.691+log(lufs_s_sum_max)*10/log(10));
gfx_drawstr(#str);

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = 20; gfx_y = 110;
gfx_drawstr("LUFS Momentary:");
gfx_x = 180; gfx_y = 110;
sprintf(#str, "%.1f LUFS", lufs_m_db);
lufs_m_db > -100 ? (
gfx_drawstr(#str);
) : (
gfx_drawstr("---")
);
gfx_x = 300; gfx_y = 110;
gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
sprintf(#str, "(max: %.1f)", -0.691+log(lufs_m_sum_max)*10/log(10));
gfx_drawstr(#str);

// LRA Display
gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = 20; gfx_y = 140;
gfx_drawstr("LRA (Loudness Range):");
gfx_x = 180; gfx_y = 140;
lra_db_diff > 0 ? (
  sprintf(#str, "%.1f LU", lra_db_diff+0.01);
  gfx_drawstr(#str);
) : (
  gfx_drawstr("---");
);

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = 20; gfx_y = 170;
gfx_drawstr("True Peak L:");
gfx_x = 180; gfx_y = 170;
sprintf(#str, "%.2f dBTP", tp_l_db);
tp_l_db > -1 ? (gfx_r = 1; gfx_g = 0; gfx_b = 0;);
tp_l_db > -150 ? (
gfx_drawstr(#str);
) : (
gfx_drawstr("---")
);

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = 20; gfx_y = 200;
gfx_drawstr("True Peak R:");
gfx_x = 180; gfx_y = 200;
sprintf(#str, "%.2f dBTP", tp_r_db);
tp_r_db > -1 ? (gfx_r = 1; gfx_g = 0; gfx_b = 0;);
tp_r_db > -150 ? (
gfx_drawstr(#str);
) : (
gfx_drawstr("---")
);

// Goniometer
gonio_x = 50;
gonio_y = 270;
gonio_size_display = 180;
gonio_half = gonio_size_display / 2;
gonio_scale = gonio_half * 0.95;

gonio_pos > 0 ? (

gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.15;
gfx_circle(gonio_x + gonio_half, gonio_y + gonio_half, gonio_half, 0);

gfx_r = 0.3; gfx_g = 0.3; gfx_b = 0.3;
gfx_line(gonio_x + gonio_half*0.5, gonio_y + gonio_half*0.5,
         gonio_x + gonio_half*1.5, gonio_y + gonio_half*1.5);
gfx_line(gonio_x + gonio_half*0.5, gonio_y + gonio_half*1.5,
         gonio_x + gonio_half*1.5, gonio_y + gonio_half*0.5);

gfx_r = 0.25; gfx_g = 0.25; gfx_b = 0.25;
gfx_line(gonio_x + gonio_half, gonio_y, gonio_x + gonio_half, gonio_y + gonio_size_display);
gfx_line(gonio_x, gonio_y + gonio_half, gonio_x + gonio_size_display, gonio_y + gonio_half);

gfx_r = 0; gfx_g = 0.6; gfx_b = 1;
gfx_a = 0.6;
i = 0;
rot = -45 * 0.017453292;
samples_to_draw = gonio_pos;
loop(samples_to_draw,
  idx = i;
  L = gonio_buffer_L[idx];
  R = gonio_buffer_R[idx];

  // --- Normalize L and R to keep the plot inside bounding box ---
  peak = max(abs(L), abs(R));
  peak > 1.5 ? (L /= peak; R /= peak;);

  s0 = sign(L);
  s1 = sign(R);
  R != 0 ? angle = atan(L / R) : (L > 0 ? angle = 1.570796327 : angle = 4.71238898);
  (s0 == 1 && s1 == -1) || (s0 == -1 && s1 == -1) ? angle += 3.141592654;
  s0 == -1 && s1 == 1 ? angle += 6.283185307;
  L == 0 ? (R > 0 ? angle = 0 : angle = 3.141592654);

  radius = sqrt(L*L + R*R);
  angle -= rot;

  vert = cos(angle) * radius;
  horiz = sin(angle) * radius;

  plot_x = gonio_x + gonio_half + vert * gonio_scale;
  plot_y = gonio_y + gonio_half - horiz * gonio_scale;

  i > 0 ? (
    gfx_line(last_x, last_y, plot_x, plot_y);
  );

  last_x = plot_x;
  last_y = plot_y;

  i += 1;
);

gfx_a = 1;
gfx_r = 0.8; gfx_g = 0.8; gfx_b = 0.8;
gfx_x = gonio_x + gonio_half*0.3; gfx_y = gonio_y + gonio_half*0.4;
gfx_drawstr("L");
gfx_x = gonio_x + gonio_half*1.6; gfx_y = gonio_y + gonio_half*0.4;
gfx_drawstr("R");
gfx_x = gonio_x + gonio_half - 5; gfx_y = gonio_y;
gfx_drawstr("M");
gfx_x = gonio_x; gfx_y = gonio_y + gonio_half - 5;
gfx_drawstr(" +S");
gfx_x = gonio_x + gonio_size_display - 20; gfx_y = gonio_y + gonio_half - 5;
gfx_drawstr("-S");

gonio_pos = 0;

);


gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = gonio_x + gonio_half - 40; gfx_y = gonio_y + gonio_size_display + 10;
gfx_drawstr("Goniometer");

// Phase Meter
phase_meter_x = 328;
phase_meter_y = 350;
phase_meter_w = 250;
phase_meter_h = 30;

gfx_r = 0.1; gfx_g = 0.1; gfx_b = 0.1;
gfx_rect(phase_meter_x, phase_meter_y, phase_meter_w, phase_meter_h);

gfx_r = 0.5; gfx_g = 0.5; gfx_b = 0.5;
gfx_line(phase_meter_x + phase_meter_w/2, phase_meter_y, phase_meter_x + phase_meter_w/2, phase_meter_y + phase_meter_h);

phase_pos = phase_meter_x + phase_meter_w/2 + (phase_correlation * phase_meter_w/2);
phase_correlation < 0 ? (
  gfx_r = 1; gfx_g = 0.6; gfx_b = 0;
) : (
  gfx_r = 0; gfx_g = 0.6; gfx_b = 1;
);
gfx_rect(phase_pos - 2, phase_meter_y, 4, phase_meter_h);

gfx_r = 0.8; gfx_g = 0.8; gfx_b = 0.8;
gfx_x = phase_meter_x; gfx_y = phase_meter_y + phase_meter_h + 5;
gfx_drawstr("-1");
gfx_x = phase_meter_x + phase_meter_w - 15; gfx_y = phase_meter_y + phase_meter_h + 5;
gfx_drawstr("+1");
gfx_x = phase_meter_x + phase_meter_w/2 - 5; gfx_y = phase_meter_y + phase_meter_h + 5;
gfx_drawstr("0");

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = phase_meter_x + 30; gfx_y = phase_meter_y - 50;
gfx_drawstr("Phase Correlation:");
gfx_x = phase_meter_x + 175; gfx_y = phase_meter_y - 50;
sprintf(#str, "%.3f", phase_correlation);
phase_correlation < 0 ? (gfx_r = 1; gfx_g = 0.5; gfx_b = 0;);
gfx_drawstr(#str);


mtstart     = gfx_texth * 3;
mtrange     = gfx_w/2.5;
// Place the bitmeter a bit higher
mtvalstart  = gfx_h - 75;        // meter Y-position
mtvalrange  = 600;                // how tall the meter is

i = 0;
loop(65,

  x = mtstart + mtrange*(i-1)/64;
  y = mtvalstart;

  tick = !(i&7);

  tick ?
  (
    // measure the number width
    sprintf(#txt, "%d", i);
    gfx_measurestr(#txt, tw, th);

    // center it on the tick
    gfx_x = x - tw*0.5;
    gfx_y = y + gfx_texth;

    gfx_r = 0; gfx_g = 0.6; gfx_b = 1;
    gfx_drawstr(#txt);
  );

  i > 0 ?
  (
    val = bbuf[64-i];

    val > 0.0 ?
    (
      gfx_r = 0; gfx_g = tick ? 1.0 : 0.625; gfx_b = 1;
    ) : (
      gfx_r = gfx_g = gfx_b = tick ? 0.75 : 0.5;
    );

    gfx_x = x;
    gfx_y = y;

    gfx_lineto(x, y - 2 - mtvalrange*0.1*val);
  );

  i += 1;
);

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_setfont(1, "Arial", 14);
gfx_x = mtstart + mtrange * 0.44;  // center horizontally
gfx_y = gfx_h-35;               // safely inside window
gfx_drawstr("Bitmeter", 1);



// ==================================================================================
   
  gfx_ext_retina > 1 ? (
    gfx_setfont(1,"Arial",20,'b');
    gfx_setfont(2,"Arial",18,'b');
  ) : (
    gfx_setfont(1,"Arial",12,'b');
    gfx_setfont(2,"Arial",10,'b');
  );
  gfx_setfont(1);

actual_width = gfx_w / gfx_ext_retina;
actual_height = gfx_h / gfx_ext_retina;

// Calculage compact view flags
// These are used to disable certain elements for graceful visual shrinking
compact_width = actual_width < 600;
compact_height = actual_height < 320;

gfx_ext_retina != 2 ? (
  very_compact_width = (actual_width < 450);
  very_compact_height = (actual_height < 240);
) : (
  very_compact_width = (actual_width < 300);
  very_compact_height = (actual_height < 160);
);

very_compact_width | very_compact_height ? (
  spectrum.bottom_margin = -18 * gfx_ext_retina;
) : ( 
  spectrum.bottom_margin = gfx_h/2;
  spectrum.left_margin = gfx_w/2+40;
  spectrum.top_margin = 20;
  spectrum.right_margin= 20;
);

Display_Mode < 2 ? (
  spectrum.draw(0);
  Spectrum_Mode == 3 || Spectrum_Mode == 6 ? spectrum.draw(1);
);

ht = (gfx_h/2 - spectrum.bottom_margin - gfx_texth) + 2;

dst_a = 0.55 / ht;
gfx_gradrect(0, ht/2, gfx_w, ht/2, 0,0,0,0,    0, 0, 0, 0, 0, 0, 0, dst_a*2); 

!((very_compact_width) | (very_compact_height)) ? (
  spectrum.draw_grid(0);
);

chr = gfx_getchar();

mouse_cap & 8 ? (
  do_listen = 1;
  draw_listen_helper();

  mw = mouse_wheel;
  md = -(mw - last_wheel) / 120;
  last_wheel = mw;

  listen_width += md / 200;
  listen_width = min(0.30, listen_width);
  listen_width = max(0.01, listen_width);

) : do_listen = 0;

draw_info_panel(note_select);

note_select == 0 ? (
  draw_mouse_crosshair();
); 

!((very_compact_width) | (very_compact_height)) ? (
  
  gfx_ext_retina == 2 ? (peaks.x = gfx_w - 150; peaks.width = 100;) : (peaks.x = gfx_w - 100; peaks.width = 60;);
  gfx_ext_retina == 2 ? (mode_button.x = gfx_w - 400; mode_button.width = 120;) : (mode_button.x = gfx_w - 280; mode_button.width = 80;);
  gfx_ext_retina == 2 ? (channel_button.x = gfx_w - 280; channel_button.width = 120;) : (channel_button.x = gfx_w - 200; channel_button.width = 80;);
  mode_button.draw_mode_button();
  mode_button.handle_mode_button();
  // Only draw channel button if not in Full mode
  strcmp(mode_button.label, prev_mode_label) != 0 ? (
    strcmp(mode_button.label, "Mid/Side") == 0 ? (
      channel_button.label = "Mid+Side";
      Spectrum_Mode = 3;
   );
    strcmp(mode_button.label, "Left/Right") == 0 ? (
      channel_button.label = "Left+Right";
      Spectrum_Mode = 6;
    );
    // Update previous mode
    prev_mode_label = mode_button.label;
  );
  // Draw + handle channel button only if not Full mode
  strcmp(mode_button.label, "Full") != 0 ? (
      channel_button.draw_channel_button();
      channel_button.handle_channel_button(mode_button.label);
  );
  peaks.draw_peak_button();
  peaks.handle_peak_button();
);

//==================================================================================
// Spectrogram gfx
//==================================================================================

need_clear_spectro ? (
  need_clear_spectro = 0;
  cur_xpos = 0;
  
  // Clear the spectrogram area (bottom-right quadrant)
  gfx_r = gfx_g = gfx_b = 0;
  gfx_a = 1;
  gfx_x = gfx_w/2;
  gfx_y = gfx_h/2;
  gfx_rectto(gfx_w, gfx_h);
);

gfx_ext_retina>1 ? gfx_setfont(1,"Arial",16*gfx_ext_retina,'b') : gfx_setfont(0);

old_w != gfx_w || old_h!=gfx_h? (
  small_mode = gfx_w<200*gfx_ext_retina || gfx_h<200*gfx_ext_retina;
  cur_xpos=0;
  old_w=gfx_w; old_h=gfx_h;
  
  gfx_r=gfx_g=gfx_b=0; gfx_a=1;
  gfx_x=gfx_y=0;
  gfx_rectto(gfx_w,gfx_h);
  need_button_refs=1;
);

use_h = small_mode ? gfx_h : (gfx_h-gfx_texth - 4);

function calc_color(mv, col*) globals(over24)
(
  col.r = col.g = col.b = 0; // start with black

  // Very quiet -> almost black, deep blue
  mv <= -96 ? (
    mv > -168 ? (
      mv <= -144 ? ( col.b = (mv+168)*over24*0.1; col.r = (mv+168)*over24*0.02 ) :  // very dark blue/black
      mv <= -120 ? ( col.b = 0.1 + (mv+144)*over24*0.12; col.r = 0.02 + (mv+144)*over24*0.04 ) : // slightly brighter
                   ( col.r = (mv+120)*over24*0.08; col.b = 0.2 + (mv+120)*over24*0.12 )
    )
  ) : (
    // Medium -> more vibrant purple-blue shades
    mv <= -72 ? ( col.r = (mv+96)*over24*0.3; col.b = 0.5 + (mv+96)*over24*0.25 ) :
    mv <= -48 ? ( col.r = 0.3 + (mv+72)*over24*0.25; col.b = 0.7 + (mv+72)*over24*0.15 ) :
    mv <= -24 ? ( col.r = 0.55 + (mv+48)*over24*0.2; col.b = 0.85 - (mv+48)*over24*0.1 ) :
    mv <= 0  ? ( col.r = 0.7 + (mv+24)*over24*0.15; col.b = 0.75 + (mv+24)*over24*0.1 ) :
      col.r = 0.85; col.b = 0.85;  // loudest -> vibrant purple-blue
  );
);

reccnt>0 ? (
    amt = min(reccnt,histsize*2);
    reccnt=0;
    drecpos = amt/pixels_per_frame;
    lrecpos = rec_write_pos - amt;
    draw_pos=0;

    loop(pixels_per_frame,

        windowsize != fftsize || windowtype != 2 ? (
            windowtype=2; 
            windowsize=fftsize;
            i=0;
            dwindowpos = $pi*2/fftsize;
            windowpos=0;
            pwr=0;
            loop(fftsize*.5+1,
                pwr += (window[i] =  (
                    windowtype==1 ? 0.53836 - cos(windowpos)*0.46164 :
                    windowtype==2 ? 0.35875 - 0.48829 * cos(windowpos) + 0.14128 * cos(2*windowpos) - 0.01168 * cos(3*windowpos) :
                    windowtype==3 ? 0.42 - 0.50 * cos(windowpos) + 0.08 * cos(2.0*windowpos) :
                    1.0));
                windowpos+=dwindowpos;
                i+=1;
            );
            pwr=1.0/(pwr*2-window[i-1]);
            loop(fftsize,window[i-=1]*=pwr; );
        );

        lrecpos += drecpos;

        buf1=(lrecpos|0)-fftsize;
        buf1<0 ? buf1+=histsize;
        buf2=window;
        buf3=fftworkspace;
        loop(fftsize*.5+1,
            buf3[] = recpos[buf1]*buf2[];
            buf3[1]=0;
            buf3+=2;

            buf2+=1;
            (buf1+=1) >= histsize ? buf1 -= histsize;
        );
        buf2-=1;
        loop(fftsize*.5-1,
            buf3[] = recpos[buf1]*(buf2-=1)[];
            buf3[1]=0;
            buf3+=2;

            (buf1+=1) >= histsize ? buf1 -= histsize;
        );
        fft(fftworkspace,fftsize);
        fft_permute(fftworkspace,fftsize);

        lfftpos=0;
        i=0;
        lscale=10/log(10);
        scroll=0;
        !(mouse_cap&1) || cap_mode>0 ? (
            scroll ? (
                gfx_a=1;
                cur_xpos = gfx_w/2 - 1 - pixels_per_frame + draw_pos;
                draw_pos==0 ? (
                    gfx_blit(
                        -1,
                        pixels_per_frame, 0,
                        pixels_per_frame, 0,
                        gfx_w/2 - pixels_per_frame + gfx_w/2,  // x offset into bottom-right
                        gfx_h/2,                                // y offset into bottom-right
                        0, 0,
                        gfx_w/2 - pixels_per_frame,
                        gfx_h/2
                    );
                ) : 0;
            ) : (
                // Fade mode: dark rectangle
                gfx_a = 0.1;
                gfx_r = gfx_g = gfx_b = 0 ;

                fade_width = 15;
                gfx_x = gfx_w/2 + cur_xpos; // bottom-right quadrant start
                gfx_y = gfx_h/2;            // vertical start

                end_x = gfx_x + fade_width;
                end_y = gfx_h;

                end_x > gfx_w ? end_x = gfx_w : 0;

                gfx_rectto(end_x, end_y);
            );

            uselm = islogmode;
            sc = (uselm ? (1.0/log(1+g_logscale)) : (1.0/(gfx_h/2-20))) * 0.5*fftsize;
            sc2=g_logscale/(gfx_h/2-20);

            loop(gfx_h/2-20,
                tpos = (uselm ? ((fftsize*0.5 - 1 - log(1+(gfx_h/2-20-1-i)*sc2)*sc)) : i*sc)|0;
                tpos >= fftsize*0.5 ? tpos=fftsize*0.5;
                lfftpos >= tpos ? ( lfftpos=tpos-1; );
                spectro_mv=0;

                loop(tpos-lfftpos,
                    usei = max(lfftpos,0)*2;
                    aa=fftworkspace[usei]; 
                    bb=fftworkspace[usei+1];
                    spectro_dv=aa*aa+bb*bb;
                    spectro_dv < 1.0*10^-20 ? spectro_dv = 1.0*10^-20 : 0;
                    spectro_dv>spectro_mv ? spectro_mv=spectro_dv;

                    lfftpos+=1;
                );
                spectro_mv=spectro_mv <= minvol ? -200 : log(spectro_mv)*lscale;

                // Draw pixels in bottom-right quadrant
                gfx_x = gfx_w/2 + cur_xpos;
                gfx_y = use_h - (i+1);  // bottom half
                gfx_a = 1;

                calc_color(spectro_mv, drawc);
                gfx_setpixel(drawc.r, drawc.g, drawc.b);

                i+=1;
            );

            cur_xpos+=1;
            cur_xpos >= gfx_w/2 - 15 ? cur_xpos=0;
            draw_pos+=1;
        );
    );
);

gfx_x=gfx_w/2;
gfx_y=use_h;
gfx_r=gfx_g=gfx_b=0;
gfx_a=1;
gfx_rectto(gfx_w,gfx_h);

mouse_x >= gfx_w/2 && mouse_x < gfx_w - 20 &&
mouse_y >= gfx_h/2 && mouse_y < gfx_h ? (
  !(mouse_cap&1) ? mb=-169;
  bla=0;
  loop(9,
    gfx_x=mouse_x - 1 + (bla%3); 
    gfx_y=mouse_y - 1 + (bla/3);
    gfx_getpixel(r,g,b); 

    r||g||b ? 
    ( 
      val = i = -169;
      bestdist = 10000000000;
      while (i<=0)
      (        
        calc_color(i,tmp);
        dist = sqr(tmp.r-r)+sqr(tmp.g-g)+sqr(tmp.b-b);
        dist < bestdist ? ( val=i; bestdist=dist; );
        i+=1;
      );
      mb = max(mb,val);
    );
    bla+=1;
  );
  (

  // Top and bottom of the spectrogram in pixels
  top_pixel    = gfx_h/2 - 20;
  bottom_pixel = use_h;
  // Clamp mouse_y to the visible spectrogram area
  clamped_y = max(top_pixel, min(mouse_y, bottom_pixel-1));
  // Compute pixel index (bottom-up, matches gfx_y = use_h - (i+1))
  i = bottom_pixel - 1 - clamped_y;
  // Map pixel index to FFT bin
  bin_index = i * (0.5 * fftsize) / (gfx_h/2-20);
  // Convert FFT bin to Hz
  converted_hz = bin_index * srate / fftsize;


    // converted_hz=(1-disp_hz)*srate*0.5;
    sprintf(#infostr,"%.0fHz",converted_hz);
    
    mb > -168 ? (
     sprintf(#infostr, "%s %.1fdB",#infostr,mb);
    ) : (
     #infostr += " -oodB";
    );
    
    gfx_measurestr(#infostr,wid,0);
    gfx_x=max((gfx_w-15)-wid,g_button_right_extent+4);
    gfx_y=use_h + 2;
    gfx_r=gfx_g=gfx_b=1;
    mouse_x > gfx_w/2 && mouse_y > (gfx_h/2) && converted_hz >= 0 ? (gfx_drawstr(#infostr));
  );
);

//==================================================================================

has_click = (mouse_cap&1 && !last_cap) ? 1 : 0;
has_click && mouse_x < 375 && mouse_y < 225 ? Reset();
last_cap = mouse_cap;
