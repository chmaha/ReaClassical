Version: 1.02
desc:ReaVision Metering Suite (chmaha)
author: chmaha
about:
  Released under GPLv3 license
  Includes DSP (LGPL) from:
  Cockos Loudness Meter Copyright (C) 2021 and later Cockos Incorporated
  Cockos Bit Meter Copyright (C) 2020 and later Cockos Incorporated
  Spectrograph Meter Copyright (C) 2007 Cockos Incorporated
  https://www.gnu.org/licenses/lgpl-3.0.html
  Includes DSP (MIT License) from:
  ReJJ ReSpectrum Copyright (c) 2021 Justin Johnson
  https://github.com/Justin-Johnson/ReJJ/tree/master/ReSpectrum

slider1:Spectrum_Mode=0<0,5,1{Full,Mid,Side,Mid / Side,Left,Right,Left / Right}>-Spectrum
slider2:Display_Mode=0<0,2,1{Fill,Line,None}>-Display
slider3:Ceiling_Value=0<0,2,1{0dB,20dB,40dB}>-Ceiling
slider4:Floor_Value=0<0,2,1{-90dB,-140dB,-200dB}>-Floor
slider5:Tilt_Value=3<0,5,1{0dB/oct,1.5dB/oct,3dB/oct,4.5dB/oct,6dB/oct}>-Tilt
slider6:Type_Value=1<0,3,1{Hamming,Blackman-Harris,Blackman,Rectangular}>-Type
slider7:Block_Value=2<0,3,1{2048,4096,8192,16384}>-Block Size
slider8:Show_Piano=0<0,1,1{Off,On}>-Show Piano
slider9:Show_Peaks=0<0,1,1{Off,On}>-Show Peaks

import Dependencies/chmaha_spectrum.jsfx-inc
import Dependencies/svf_filter.jsfx-inc

options:no_meter

@init

gfx_ext_retina=max(gfx_ext_retina,1);
ext_nodenorm = 1;
ext_noinit = 1;

// K-20 meter init
k20_l.z1 = k20_l.z2 = k20_l.rms = k20_l.peak = 0;
k20_l.cnt = k20_l.fpp = 0;
k20_r.z1 = k20_r.z2 = k20_r.rms = k20_r.peak = 0;
k20_r.cnt = k20_r.fpp = 0;

function k20_init() (
  this.hold_samples = (0.5 * srate + 0.5)|0;  // 0.5 second hold
  this.omega = 9.72 / srate;  // Ballistic filter coefficient
  this.z1 = this.z2 = this.rms = this.peak = 0;
  this.cnt = 0;
  this.fall = 1;
);

function k20_process(sample) local(s, t) (
  s = sample * sample;
  
  // Update ballistic filters
  this.z1 += this.omega * (s - this.z1);
  this.z2 += this.omega * (this.z1 - this.z2);
  
  // Clamp filter states
  this.z1 = max(0, min(50, this.z1));
  this.z2 = max(0, min(50, this.z2));
  
  // RMS from second filter
  this.rms = sqrt(2.0 * this.z2);
  
  // Digital peak tracking
  t = abs(sample);
  t >= this.peak ? (
    this.peak = t;
    this.cnt = this.hold_samples;
  ) : this.cnt > 0 ? (
    this.cnt -= 1;
  ) : (
    this.peak *= this.fall;
    this.peak += 1*10^-10;
  );
);

k20_l.k20_init();
k20_r.k20_init();

//==================================================================================
// Spectrogram init
//==================================================================================

gfx_clear=-1;
windowtype=-1;
over24=1/24;
first_load = 1; 

lrecpos=0;

fftsize=2^10;
lfft=fftsize;
histsize=fftsize*4;
minvol=10^(-180/20*2); // squared
islogmode = 0;
g_logscale=1;
pixels_per_frame = 1;
need_button_refs=1;
rec_write_pos = 0;

function calc_color(mv, col*) globals(over24)
(
  col.r = col.g = col.b = 0; // start with black

  // Very quiet -> almost black, deep blue
  mv <= -96 ? (
    mv > -168 ? (
      mv <= -144 ? ( col.b = (mv+168)*over24*0.1; col.r = (mv+168)*over24*0.02 ) :  // very dark blue/black
      mv <= -120 ? ( col.b = 0.1 + (mv+144)*over24*0.12; col.r = 0.02 + (mv+144)*over24*0.04 ) : // slightly brighter
                   ( col.r = (mv+120)*over24*0.08; col.b = 0.2 + (mv+120)*over24*0.12 )
    )
  ) : (
    // Medium -> more vibrant purple-blue shades
    mv <= -72 ? ( col.r = (mv+96)*over24*0.3; col.b = 0.5 + (mv+96)*over24*0.25 ) :
    mv <= -48 ? ( col.r = 0.3 + (mv+72)*over24*0.25; col.b = 0.7 + (mv+72)*over24*0.15 ) :
    mv <= -24 ? ( col.r = 0.55 + (mv+48)*over24*0.2; col.b = 0.85 - (mv+48)*over24*0.1 ) :
    mv <= 0  ? ( col.r = 0.7 + (mv+24)*over24*0.15; col.b = 0.75 + (mv+24)*over24*0.1 ) :
      col.r = 0.85; col.b = 0.85;  // loudest -> vibrant purple-blue
  );
);

//==================================================================================
// Spectrum analyzer init
//==================================================================================

prev_mode_label = "";
spectrum.mem_index = 0;

/*
 * Round number up or down
 */
function round(in) (
  floor(in + 0.5 * sign(in));
);

/*
 * Standard log2
 */
function log2(x) ( 
  log(x) / log(2);
);

/*
 * Return string of integer
 */
function int2str(intIn) local (outStr) (
  strcpy(outStr=#,"");
  sprintf(outStr,"%d",intIn);
  outStr;
);

/*
 * Update the state of any changes
 */
function update_state() local (blocks) (
  spectrum.ceiling = Ceiling_Value == 0 ? 0 : Ceiling_Value == 1 ? 20 : Ceiling_Value == 2 ? 40;
  spectrum.noise_floor = Floor_Value == 0 ? -90 : Floor_Value == 1 ? -140 : Floor_Value == 2 ? -200;
  spectrum.noise_floor = Floor_Value == 0 ? -90 : Floor_Value == 1 ? -140 : Floor_Value == 2 ? -200;
  spectrum.tilt = Tilt_Value == 0 ? 0 : Tilt_Value == 1 ? 1.5 : Tilt_Value == 2 ? 3 : Tilt_Value == 3 ? 4.5 :
                  Tilt_Value == 4 ? 6;

  spectrum.windowtype != Type_Value+1 ? spectrum.set_type(Type_Value+1);

  blocks = (2 ^ (Block_Value+1)) * 1024;

  spectrum.windowsize != blocks ? spectrum.set_block_size(blocks);

  Display_Mode == 0 ? (
    fill_r = 0 / 255;
    fill_g = 153 / 255;
    fill_b = 255 / 255;
    fill_a = 0.5;
    spectrum.set_fill(0, 1);
    spectrum.set_color(0, fill_r, fill_g, fill_b, fill_a);
    fill_r =  0 / 255;
    fill_g = 255 / 255;
    fill_b = 255 / 255;
    fill_a = 0.5;
    spectrum.set_fill(1, 1); 
    spectrum.set_color(1, fill_r, fill_g, fill_b, fill_a);
  ) : Display_Mode == 1 ? (
    line_a=1.0;
    line_r = 0 / 255; line_g = 153 / 255; line_b = 255 / 255;;
    spectrum.set_fill(0, 0);
    spectrum.set_color(0, line_r, line_g, line_b, line_a);
    line_r = 253 / 255; line_g = 185 / 255; line_b = 21 / 255;;
    spectrum.set_fill(1, 0);
    spectrum.set_color(1, line_r, line_g, line_b, line_a);
  );
);

/*
 * Draw a crosshair where the mouse is
 */
function draw_mouse_crosshair() (
  mouse_x >= 0 && mouse_x > gfx_w/2 && mouse_y >=0 && mouse_y < gfx_h/2-16 ? (
    gfx_set(1.0, 1.0, 1.0, 0.3);
    gfx_line(gfx_w/2,mouse_y,gfx_w,mouse_y,1);
    gfx_line(mouse_x,0,mouse_x,gfx_h/2-16,1);
  );
);

/*
 * Draw a round cornered rectangle
 */
function draw_filled_rect(x, y, w, h, rad, alias) ( 
    gfx_circle(x+rad, y+rad, rad, 1, alias);
    gfx_circle(x+w-rad-1, y+rad, rad, 1, alias);
    gfx_circle(x+w-rad-1, y+h-rad-1, rad, 1, alias);
    gfx_circle(x+rad, y+h-rad-1, rad, 1, alias);

    gfx_rect(x, y+rad, rad*2, h-rad*2, alias);
    gfx_rect(x+w-rad*2, y+rad, rad*2, h-rad*2, alias);
    gfx_rect(x+rad, y, w-rad*2, rad*2, alias);
    gfx_rect(x+rad, y+h-rad*2, w-rad*2, rad*2, alias);

    gfx_rect(x+rad, y+rad, w-rad*2, h-rad*2, alias);
);

/*
 * Draw the info panel showing frequency, note, cent and dB
 */
function draw_info_panel(note_select)
  local(read_freq, read_amp, q, band, C0, semi, octave, note, cent, keys, nn, note_freq, centstr, width, xpos, xpos2, ypos)
 (
  mouse_x >= gfx_w/2 && mouse_x < gfx_w && mouse_y >= 0 && mouse_y < gfx_h/2 ? (
    gfx_set(0, 0.5, 1);
    read_freq = note_select == 0 ? spectrum.x_to_freq(mouse_x) : note_select;
    read_amp = spectrum.y_to_db(mouse_y);
    
    // Position in lower corner of upper right quadrant
    width = 130;
    gfx_ext_retina != 2 ? width -= 40;
    
    xpos = gfx_w/2 + 10;
    xpos2 = xpos + 55;
    gfx_ext_retina != 2 ? xpos2 -= 15;
    ypos = 20;  // Bottom of upper half, minus panel height and margin
    
    gfx_x = xpos;
    gfx_y = ypos;
    
    // Black background with transparency
    gfx_r = 0; gfx_g = 0; gfx_b = 0; gfx_a = 0.7;
    gfx_rect(gfx_x-5, gfx_y-5, width, gfx_texth*4, 1);
    
    // Blue border with transparency
    gfx_r = (0 / 255); gfx_g = (153 / 255); gfx_b = (255 / 255); gfx_a = 0.5;
    gfx_rect(gfx_x-10, gfx_y-10, width, gfx_texth*4, 1);
    
    // Light blue text
    gfx_r = 114 / 255; gfx_g = 215 / 255; gfx_b = 253 / 255; gfx_a = 1.0;
    gfx_ext_retina != 2 ? gfx_y -= 8;
    
    read_freq < 100 ? ( gfx_drawstr(sprintf(#,"%.1f Hz", read_freq)) ) :
      (read_freq < 1000 ? ( gfx_drawstr(sprintf(#,"%.0f Hz", read_freq)) ) : ( 
        (read_freq < 10000 ? ( gfx_drawstr(sprintf(#,"%.2f kHz", read_freq/1000)) ) : ( 
          gfx_drawstr(sprintf(#,"%.1f kHz", read_freq/1000));
        )
      )
    ));
    
    // 440Hz is A4, get C0 as offset from that
    C0 = 440 * pow(2, -4.75);
    // Get seminotes (note number), octave and note within octave
    semi = round(12 * log2(read_freq / C0));
    octave = floor(semi / 12);
    note = (semi % 12);
    // Calculate cents
    note_freq = C0 * 2.71828 ^ (0.0577623 * semi);
    cent = floor(1200 * log2(read_freq / note_freq));
    // The above math goes a bit screwy for our -1 lowest octave.
    // We get a kind of inverse reflection.  This fixes it up.
    octave == -1 ? (
      note = (13 - (-(semi))) % 12;
      cent = -(99 - cent);
    );
    // Display it all
    keys="CCDDEFFGGAAB";
    strcpy_substr(nn=#,keys,note,1);
    note==1 || note==3 || note==6 || note==8 || note==10 ? strcat(nn,"#");
    strcat(nn, int2str(octave));
    cent < 0 ? strcpy(centstr=#,"-") : strcpy(centstr=#,"+");
    abs(cent) <= 9 ? strcat(centstr, "0");
    strcat(centstr, sprintf(#, "%d", abs(cent)));
    
    gfx_x = xpos;
    gfx_y += gfx_texth+2;
    gfx_drawstr(nn);
    gfx_x = xpos2;
    gfx_drawstr(centstr);
    gfx_x = xpos;
    gfx_y += gfx_texth+2;
    gfx_drawstr(sprintf(#,"%.1f DB", read_amp));
  );
);

/*
 * Initialize the mode button
 */
function init_mode_button(xpos, ypos, buttonwidth) instance (x, y, width, label) (
  x = xpos;
  y = ypos;
  width = buttonwidth;
  label = "Full";
);

/*
 * Initialize the channel button (appears when in Mid/Side or Left-Right mode)
 */
function init_channel_button(xpos, ypos, buttonwidth) instance (x, y, width, label) (
  x = xpos;
  y = ypos;
  width = buttonwidth;
  label = "Mid+Side";
);

/*
 * Draw the mode button
 */
function draw_mode_button() instance (x, y, width, label, height) local(w, h, a) ( 
  mouse_x >= gfx_w/2 && mouse_x < gfx_w && mouse_y >= 0 && mouse_y < gfx_h/2 ? (
    gfx_a = 1;
    gfx_measurestr(label, w, h);
    height = h + 8;
    mouse_x >= x && mouse_x <= x+width && mouse_y >= y && mouse_y <= y + height ? ( 
      gfx_r = (0 / 255);
      gfx_g = (153 / 255);
      gfx_b = (255 / 255);
      gfx_a = 0.6;
    ) : (
      gfx_r = (0 / 255);
      gfx_g = (153 / 255);
      gfx_b = (255 / 255);
      gfx_a = 0.4;
    );
    gfx_rect(x, y, width, h+9, 1);
    
    gfx_r = (114 / 255);
    gfx_g = (215 / 255);
    gfx_b = (253 / 255);
    gfx_a = 1;
    gfx_x = x + (width / 2) - (w / 2);
    gfx_y = y + 4;
    gfx_drawstr(label);
  );
);

/*
 * Draw the channel button (only visible in Mid/Side or Left-Right mode)
 */
function draw_channel_button() instance (x, y, width, label, height) local(w, h, a) ( 
  mouse_x >= gfx_w/2 && mouse_x < gfx_w && mouse_y >= 0 && mouse_y < gfx_h/2 ? (
    gfx_a = 1;
    gfx_measurestr(label, w, h);
    height = h + 8;
    mouse_x >= x && mouse_x <= x+width && mouse_y >= y && mouse_y <= y + height ? ( 
      gfx_r = (0 / 255);
      gfx_g = (153 / 255);
      gfx_b = (255 / 255);
      gfx_a = 0.6;
    ) : (
      gfx_r = (0 / 255);
      gfx_g = (153 / 255);
      gfx_b = (255 / 255);
      gfx_a = 0.4;
    );
    gfx_rect(x, y, width, h+9, 1);
    
    gfx_r = (114 / 255);
    gfx_g = (215 / 255);
    gfx_b = (253 / 255);
    gfx_a = 1;
    gfx_x = x + (width / 2) - (w / 2);
    gfx_y = y + 4;
    gfx_drawstr(label);
  );
);

/*
 * Handle clicking the mode button (Full -> Mid/Side -> Left-Right -> Full)
 */
function handle_mode_button() instance (x, y, width, label, pressed, height)
  local ()
(
  mouse_cap & 1 && !pressed ? (
    mouse_x >= x && mouse_x <= x+width && mouse_y >= y && mouse_y <= y + height ? ( 
      pressed = 1;
      
      // Cycle through modes
      strcmp(label, "Full") == 0 ? (
        label = "Mid/Side";
        Spectrum_Mode = 3;  // Default to Mid+Side when entering Mid/Side mode
      ) : strcmp(label, "Mid/Side") == 0 ? (
        label = "Left/Right";
        Spectrum_Mode = 6;  // Default to Left+Right when entering Left-Right mode
      ) : strcmp(label, "Left/Right") == 0 ? (
        label = "Full";
        Spectrum_Mode = 0;
      );
    spectrum.reset_buffers()
    ) : pressed = 0;
  ) : ( 
    !(mouse_cap & 1) ? pressed = 0;
  );
);

/*
 * Handle clicking the channel button (cycles through options based on current mode)
 */
function handle_channel_button(mode_label) instance (x, y, width, label, pressed, height)
  local ()
(
  mouse_cap & 1 && !pressed ? (
    mouse_x >= x && mouse_x <= x+width && mouse_y >= y && mouse_y <= y + height ? ( 
      pressed = 1;
      
      // Cycle based on current mode
      strcmp(mode_label, "Mid/Side") == 0 ? (
        // Mid/Side mode: Mid+Side -> Mid -> Side -> Mid+Side
        strcmp(label, "Mid+Side") == 0 ? (
          label = "Mid";
          Spectrum_Mode = 1;
        ) : strcmp(label, "Mid") == 0 ? (
          label = "Side";
          Spectrum_Mode = 2;
        ) : strcmp(label, "Side") == 0 ? (
          label = "Mid+Side";
          Spectrum_Mode = 3;
        );
      ) : strcmp(mode_label, "Left/Right") == 0 ? (
        // Left-Right mode: Left+Right -> Left -> Right -> Left+Right
        strcmp(label, "Left+Right") == 0 ? (
          label = "Left";
          Spectrum_Mode = 4;
        ) : strcmp(label, "Left") == 0 ? (
          label = "Right";
          Spectrum_Mode = 5;
        ) : strcmp(label, "Right") == 0 ? (
          label = "Left+Right";
          Spectrum_Mode = 6;
        );
      );
    spectrum.reset_buffers()
    ) : pressed = 0;
  ) : ( 
    !(mouse_cap & 1) ? pressed = 0;
  );
);

/*
 * Initialise the peaks button
 */
function init_peak_button(xpos, ypos, buttonwidth) instance (x, y, width, label) (
  x = xpos;
  y = ypos;
  width = buttonwidth;
  label = "Peaks";
);

/*
 * Draw the peaks toggle button
 */
function draw_peak_button() instance (x, y, width, menutext, label, pressed, height, label) local(w, h, a) ( 
  mouse_x >= gfx_w/2 && mouse_x < gfx_w && mouse_y >= 0 && mouse_y < gfx_h/2 ? (
  gfx_a = 1;
  gfx_measurestr(label, w, h);
  height = h + 8;
  mouse_x >= x && mouse_x <= x+width && mouse_y >= y && mouse_y <= y + height ? ( 
    gfx_r = (0 / 255);
    gfx_g = (153 / 255);
    gfx_b = (255 / 255);
    gfx_a = 0.6;
  ) : (
    Show_Peaks ? a = 0.6 : a = 0.4;
    gfx_r = (0 / 255);
    gfx_g = (153 / 255);
    gfx_b = (255 / 255);
    gfx_a = a;
  );
  gfx_rect(x, y, width, h+9, 1);
  
  Show_Peaks ? (
    gfx_r = (114 / 255);
    gfx_g = (215 / 255);
    gfx_b = (253 / 255);
  ) : ( 
    gfx_r = (114 / 300);
    gfx_g = (215 / 300);
    gfx_b = (253 / 300);    
  );
  gfx_a = 1;
  gfx_x = x + (width / 2) - (w / 2);
  gfx_y = y + 4;
  gfx_drawstr(label);
  );
);

/*
 * Handle clicking the peaks button
 */
function handle_peak_button() instance (x, y, width, label, pressed, height, label)
  local (last_clicked_item)
(
  last_clicked_item = 0;
  mouse_cap & 1 && !pressed ? (
    mouse_x >= x && mouse_x <= x+width && mouse_y >= y && mouse_y <= y + height ? ( 
      pressed = 1;

      Show_Peaks = Show_Peaks ? Show_Peaks = 0 : 1;

      spectrum.set_show_peaks(Show_Peaks);

    ) : pressed = 0;
  ) : ( 
    !(mouse_cap & 1) ? pressed = 0;
  );
);

filter.svf_set_sample_rate(srate);

gfx_ext_retina == 2 ? (
  peaks.init_peak_button(gfx_w - 150, 10, 100);
  mode_button.init_mode_button(gfx_w - 400, 10, 120);
  channel_button.init_channel_button(gfx_w - 280, 10, 120);
) : ( 
  peaks.init_peak_button(gfx_w - 100, 10, 60);
  mode_button.init_mode_button(gfx_w - 280, 10, 80);
  channel_button.init_channel_button(gfx_w - 200, 10, 80);
);

spectrum.set_show_peaks(Show_Peaks);

//==================================================================================
// Loudness, Gonio, Correl inits
//==================================================================================

function draw_text(x, y, text)
(
  // Save current color for text
  r_txt = gfx_r;
  g_txt = gfx_g;
  b_txt = gfx_b;

  // Save starting coordinates
  tx = x;
  ty = y;

  // Measure text
  gfx_measurestr(text, tw, th);

  // Rectangle dimensions
  rx = tx - 4;
  ry = ty - 4;
  rw = tw + 4;
  rh = th + 4;

  // Draw black background
  gfx_r = 0; gfx_g = 0; gfx_b = 0;
  gfx_rect(rx, ry, rw, rh, 1);  // filled

  // Restore text color
  gfx_r = r_txt; gfx_g = g_txt; gfx_b = b_txt;

  // Draw text
  gfx_x = tx;
  gfx_y = ty;
  gfx_drawstr(text);
);

<?
  nch = max(max_nch,64); // maximum channel count
  sinc_sz = 32; // true peak interpolation size
  use_mem_sinc = sinc_sz>32;

  printf("sinc_sz = %d;\n",sinc_sz);

 function do_all_channels(fmt) local(p x c) global(nch) (
   p=x=0;
   while (x < nch) (
     p+=1;
     x>0 ? printf("num_ch > %d ? ( ",x);
     c = x>=24 ? 8 : x>=8 ? 4 : 2;
     loop(c, printf(fmt,x,x); x+=1);
     printf("\n");
   );
   loop(p-1,printf(")"));
 );
?>

// Constants
WANT_INTEGRATED_ALWAYS=0;
PEAK_METER_DECAY=0.150;
LOUD_METER_UPDATE=0.100;
LOUD_METER_SPEED=0.075;
NUM_BINS=1024;
BINS_PER_DB=10;
DB_PER_BIN=1/BINS_PER_DB;
cfg_peak = 1;
ext_noinit=1;
gfx_clear=-1;
ext_nodenorm=1;
cfg_reinit=1;
attackms=50.0;
decayms=300.0;
mv=pow(2,63);

// Memory allocation
function alloc(sz) (
  memset((alloc.top += sz) - sz, 0, sz);
);

function alloc(sz) global()
(
  memset((this.top+=sz)-sz,0,sz);
);

// sinc filter for true peak
function sinc_gen_val() global(srate sinc_sz) local(sincpos windowpos) instance(slice_pos) (
  windowpos = (2.0 * $pi / sinc_sz) * slice_pos;
  sincpos = $pi * (slice_pos - sinc_sz * .5);
  slice_pos += 1;
  (0.53836 - cos(windowpos)*0.46164) * sin(sincpos) / sincpos;
);

function sinc_gen_slice(cs, o*) instance(sinc_gen_val slice_pos) local(x) global(sinc_sz) (
  slice_pos = cs;
<?
  use_mem_sinc ? (
    printf("o.v = alloc(sinc_sz);  loop(x=0;sinc_sz, o.v[x] = sinc_gen_val(); x+=1); ");
  ) : (
    loop(x=0;sinc_sz, printf("o.v%02d = sinc_gen_val();%s",x,(x&3)==3?"\n": " "); x += 1)
  );
?>
);

function sinc_init() global(srate) instance(sinc_gen_slice) (
  sinc_gen_slice(srate < 96000 ? .25 : .5,this.s1);
  srate < 96000 ? (
    sinc_gen_slice(.5, this.s2);
    sinc_gen_slice(.75, this.s3);
  );
);

<?
 function emit_sinc(hist, t) (
   use_mem_sinc ? (
    printf("abs(mem_multiply_sum(%s.v,%s.h,sinc_sz))",t,hist);
   ) : (
     printf("abs(");
     loop(x=0;sinc_sz, printf("%s.h%02d * %s.v%02d%s",hist,x,t,x,x==sinc_sz-1?"":(x&3)==3?" +\n":" + "); x+=1);
     printf(")");
   );
 );
?>

function init(chidx)
(
  this.chan=chidx;
  this.wt = chidx < 3 || num_ch < 6 ? 1 : chidx == 3 ? 0 : sqrt(2);
  this.f1p1=this.f1p2=this.f2p1=this.f2p2=0;
  this.pkval=this.hipkval=this.clips=0;
  this.ch_lufs_sum=this.ch_rms_sum=0;
  <?
    use_mem_sinc ? (
      printf("this.h = alloc(sinc_sz);\n");
    ) : (
      loop(x=0;sinc_sz, printf("this.h%02d =%s",x,x==sinc_sz-1 ? " 0" : (x&7)==7 ? "\n" : " "); x+=1);
    );
  ?>
);

function decay()
(
  this.pkval *= pk_decay;
);

function copypks() global(pk hipk clip_cnt) (
  pk[this.chan] = this.pkval;
  hipk[this.chan] = this.hipkval;
  clip_cnt[this.chan] = this.clips;
);

function proc(lspl)
  local(pspl f1p0 f2p0)
  instance(wt ch_rms_sum ch_lufs_sum pkval hipkval clips
           f1p1 f1p2 f2p1 f2p2)
  global(f1a1 f1a2 f1b0 f1b1 f1b2
         f2a1 f2a2 f2b0 f2b1 f2b2
         srate cfg_peak
         lval rval win_pos global_peak sinc_sz
         sinc.s1* sinc.s2* sinc.s3*
         )
(
  cfg_peak == 1 || cfg_peak == 2 ? (
    <?
      use_mem_sinc ? (
        printf("mem_insert_shuffle(this.h, sinc_sz, lspl);");
      ) : (
        loop(x=sinc_sz-1;sinc_sz-1, printf("this.h%02d = this.h%02d;%s",x,x-1, (x&3)==0 ? "\n" : " "); x-= 1; );
        printf(" this.h00 = lspl;");
      );
    ?>
    pspl = max(
        abs(this.h<? printf(use_mem_sinc ? "[%d]" : "%02d",sinc_sz/2) ?> ),
        <? emit_sinc("this","sinc.s1") ?>
       );
    srate < 96000 ? pspl = max(pspl,max( <? emit_sinc("this","sinc.s2") ?>,  <? emit_sinc("this","sinc.s3") ?>));
  ) :
  cfg_peak == 3 || cfg_peak == 4 ? (
    pspl=abs(lspl);
  );
  cfg_peak ? (
    pspl > pkval ? (
      pkval=pspl;
      pspl > hipkval ? (
        hipkval=pspl;
        global_peak = max(global_peak,pspl);
      );
    );
    pspl > 1.0 ? clips += 1;
  );

  win_pos == 0 ? ch_rms_sum=ch_lufs_sum=0;

  rval += (ch_rms_sum += lspl*lspl);

  lspl *= wt;

  f1p0=lspl-f1a1*f1p1-f1a2*f1p2;
  lspl=f1b0*f1p0+f1b1*f1p1+f1b2*f1p2;
  f1p2=f1p1;
  f1p1=f1p0;

  f2p0=lspl-f2a1*f2p1-f2a2*f2p2;
  lspl=f2b0*f2p0+f2b1*f2p1+f2b2*f2p2;
  f2p2=f2p1;
  f2p1=f2p0;

  lval += (ch_lufs_sum += lspl*lspl);
);

function init_lufs_filters()
  local(Vh Vb db f0 Q K a0)
  global(f1a1 f1a2 f1b0 f1b1 f1b2
         f2a1 f2a2 f2b0 f2b1 f2b2 srate)
(
  // f1,f2 could be combined into a 5th order filter

  db=3.999843853973347;
  f0=1681.974450955533;
  Q=0.7071752369554196;
  K=tan($pi*f0/srate);
  Vh=pow(10, db/20);
  Vb=pow(Vh, 0.4996667741545416);
  a0=1+K/Q+K*K;
  f1a1=2*(K*K-1)/a0;
  f1a2=(1-K/Q+K*K)/a0;
  f1b0=(Vh+Vb*K/Q+K*K)/a0;
  f1b1=2*(K*K-Vh)/a0;
  f1b2=(Vh-Vb*K/Q+K*K)/a0;

  f0=38.13547087602444;
  Q=0.5003270373238773;
  K=tan($pi*f0/srate);
  f2a1=2*(K*K-1)/(1+K/Q+K*K);
  f2a2=(1-K/Q+K*K)/(1+K/Q+K*K);
  f2b0=1;
  f2b1=-2;
  f2b2=1;
);

spectrum.init();
spectrum_mem_end = spectrum.mem_index;
alloc.top = spectrum_mem_end;
recpos = alloc(histsize);
fftworkspace = alloc(fftsize*2);
window = alloc(fftsize);

function Reset() (
  init_lufs_filters();
  alloc.top = window+fftworkspace + fftsize*2;
  pk=alloc(<?printf("%d",nch)?>);
  hipk=alloc(<?printf("%d",nch)?>);
  clip_cnt=alloc(<?printf("%d",nch)?>);
  sinc.sinc_init();

  m_win_cnt=0.4/LOUD_METER_UPDATE;
  s_win_cnt=3/LOUD_METER_UPDATE;

  win_pos=0;
  win_cnt=0;
  win_len=(LOUD_METER_UPDATE*srate)|0;
  i_win_len=1/(m_win_cnt*win_len);
  i_win_len2=1/(s_win_cnt*win_len);

  rms_m_sum=0;
  rms_m_db=-100;
  rms_m_db_max=-100;
  rms_i_sum=0;
  rms_i_sum_cnt=0;
  rms_i_db=-100;

  lufs_m_sum=0;
  lufs_m_sum_max=0;
  lufs_m_db=-100;
  lufs_s_sum=0;
  lufs_s_sum_max=0;
  lufs_s_db=-100;
  lufs_a_sum=0;
  lufs_a_sum_cnt=0;
  lufs_b_sum=0;
  lufs_b_sum_cnt=0;
  lra_db_diff = 0;
  lra_db_hi = lra_db_lo = lufs_i_db = lufs_m_db = lufs_s_db = -100;

  last_t=0;
  th_lufs_i=th_lufs_s=th_lufs_m=th_rms_i=th_rms_m=0;

  cur_buf=0;
  cur_buf2=0;
  rms_buf=alloc(m_win_cnt);
  lufs_buf=alloc(m_win_cnt);
  lufs_buf2=alloc(s_win_cnt);
  lufs_a_hist=alloc(2*NUM_BINS);
  lufs_b_hist=alloc(NUM_BINS);
  db_hist=alloc(75);
  db_hist_max=0;

  global_peak = 0;

  <? do_all_channels("ch%d.init(%d); "); ?>;

  gonio_size = 4800;
  gonio_buffer_L = alloc(gonio_size);
  gonio_buffer_R = alloc(gonio_size);
  gonio_pos = 0;

  corr_LR_sum = 0;
  corr_LL_sum = 0;
  corr_RR_sum = 0;
  corr_count = 0;

bitbuf_len = 64;

bbuf = alloc(bitbuf_len);
tbuf = alloc(bitbuf_len);

memset(bbuf, 0, bitbuf_len);
memset(tbuf, 0, bitbuf_len);

);

Reset();

@slider

update_state();

@block

// K-20 fallback calculation
k20_tme = samplesblock / srate;
k20_fall_rate = pow(10.0, -0.05 * 15.0 * k20_tme);
k20_l.fall = k20_fall_rate;
k20_r.fall = k20_fall_rate;

// Detect transport restart
!(last_play_state & 1) && (play_state & 1) ? (
  need_clear_spectro = 1;
);
last_play_state = play_state;

ifftsize=1/fftsize;

(num_ch > 0 && num_ch != last_nch) || srate != last_sr ? Reset();
last_nch = num_ch;
last_sr = srate;

cfg_reinit && (play_state&1) ? (
  abs(play_position-last_play_pos) > 0.1 ? Reset();
  last_play_pos=play_position+samplesblock/srate;
);

pk_decay=pow(0.5, samplesblock/srate/PEAK_METER_DECAY);

<? do_all_channels("ch%d.decay(); "); ?>;

dv=1.0/(sqrt(num_ch)*samplesblock);
attack=exp(-log(2.0)*samplesblock/(srate*attackms*0.001));
decay=exp(-log(2.0)*samplesblock/(srate*decayms*0.001));

bat=0;
loop
(
  64,
  bbuf[bat] *= decay;
  v=sqrt(min(tbuf[bat],1.0));
  v > bbuf[bat] ?
  (
    bbuf[bat]=bbuf[bat]*attack+v*(1.0-attack);
  ) : (
    bbuf[bat] < 0.001 ? bbuf[bat]=0.0;
  );
  tbuf[bat]=0.0;
  bat += 1;
);

@sample

// Mid/Side encode
mid = (spl0 + spl1) * 0.5;
side = (spl0 - spl1) * 0.5;

// Feed the correct buffers depending on spectrum modes
Spectrum_Mode == 0 ? spectrum.sample0(spl0 + spl1) :
Spectrum_Mode == 1 ? spectrum.sample0(mid) :
Spectrum_Mode == 2 ? spectrum.sample0(side) :
Spectrum_Mode == 3 ? (spectrum.sample0(mid); spectrum.sample1(side)) :
Spectrum_Mode == 4 ? spectrum.sample0(spl0) :
Spectrum_Mode == 5 ? spectrum.sample0(spl1) :
Spectrum_Mode == 6 ? (spectrum.sample0(spl0); spectrum.sample1(spl1));

// // Filter if we're in listen mode
// do_listen ? (
//   mono = 0.5 * (spl0 + spl1);
//   filter.svf_bp2(listen_freq, listen_q);
//   spl0 = spl1 = filter.svf_svf0(mono); 
// );

rval=lval=0;

<? do_all_channels("ch%d.proc(spl%d); "); ?>;

(win_pos += 1) >= win_len ? (
  win_pos=0;
  win_cnt += 1;

  prev_rval=rms_buf[cur_buf];
  rms_buf[cur_buf]=rval;

  prev_lval=lufs_buf[cur_buf];
  lufs_buf[cur_buf]=lval;

  prev_lval2=lufs_buf2[cur_buf2];
  lufs_buf2[cur_buf2]=lval;

  (cur_buf += 1) >= m_win_cnt ? cur_buf=0;
  (cur_buf2 += 1) >= s_win_cnt ? cur_buf2=0;

  rms_m_sum += (rval-prev_rval)*i_win_len;
  lufs_m_sum += (lval-prev_lval)*i_win_len;
  lufs_s_sum += (lval-prev_lval2)*i_win_len2;

  WANT_INTEGRATED_ALWAYS || (play_state&1) ? (
    rms_i_sum += rms_m_sum;
    rms_i_sum_cnt += 1;
    rms_i_sum > 0 && rms_i_sum_cnt >= m_win_cnt ? (
      rms_i_db=log(rms_i_sum/rms_i_sum_cnt)*10/log(10);
    ) : (
      rms_i_db=-100;
    );
  );

  rms_m_sum > 0 && win_cnt >= m_win_cnt ? (
    rms_m_db=log(rms_m_sum)*10/log(10);
    rms_m_db > rms_m_db_max ? rms_m_db_max=rms_m_db;
  ) : (
    rms_m_db=-100;
  );

  lufs_m_sum > 0 && win_cnt >= m_win_cnt ? (
    lufs_m_sum > lufs_m_sum_max ? lufs_m_sum_max=lufs_m_sum;
    lufs_m_db=-0.691+log(lufs_m_sum)*10/log(10);

    a = WANT_INTEGRATED_ALWAYS || (play_state&1) ? ((lufs_m_db+70)*BINS_PER_DB)|0 : -1;
    a >= 0 ? (
      a >= NUM_BINS ? a=NUM_BINS-1;
      lufs_a_sum += lufs_m_sum;
      lufs_a_sum_cnt += 1;
      lufs_a_hist[2*a] += 1;
      lufs_a_hist[2*a+1] += lufs_m_sum;
      db_hist_max = max(db_hist_max,db_hist[min(a*DB_PER_BIN,74)] += 1);

      lufs_a_db=-0.691+log(lufs_a_sum/lufs_a_sum_cnt)*10/log(10);
      lufs_a_gate=((lufs_a_db-10+70)*BINS_PER_DB)|0;
      lufs_i_sum=0;
      lufs_i_cnt=0;
      bin=max(lufs_a_gate,0);
      loop(NUM_BINS-bin,
        lufs_i_cnt += lufs_a_hist[2*bin];
        lufs_i_sum += lufs_a_hist[2*bin+1];
        bin += 1;
      );
      lufs_i_db=lufs_i_sum > 0 ? -0.691+log(lufs_i_sum/lufs_i_cnt)*10/log(10) : -100;
    );
  ) : (
    lufs_m_db=-100;
  );

  lufs_s_sum > 0 && win_cnt >= s_win_cnt ? (
    lufs_s_sum > lufs_s_sum_max ? lufs_s_sum_max=lufs_s_sum;
    lufs_s_db=-0.691+log(lufs_s_sum)*10/log(10);

    b = WANT_INTEGRATED_ALWAYS || (play_state&1) ? ((lufs_s_db+70)*BINS_PER_DB)|0 : -1;
    b >= 0 ? (
      b >= NUM_BINS ? b=NUM_BINS-1;
      lufs_b_sum += lufs_s_sum;
      lufs_b_sum_cnt += 1;
      lufs_b_hist[b] += 1;

      lufs_b_db=-0.691+log(lufs_b_sum/lufs_b_sum_cnt)*10/log(10);
      lufs_b_gate=((lufs_b_db-20+70)*BINS_PER_DB)|0;

      lra_cnt=0;
      bin=max(lufs_b_gate,0);
      loop(NUM_BINS-bin,
        lra_cnt += lufs_b_hist[bin];
        bin += 1;
      );
      lra_cnt >= 20 ? (
        lra_cnt_lo=lra_cnt_hi=0;
        bin=lufs_b_gate;
        while(bin < NUM_BINS && lra_cnt_lo < lra_cnt*0.10)
        (
          lra_cnt_lo += lufs_b_hist[bin];
          bin += 1;
        );
        bin_lo=bin-1;
        bin=NUM_BINS-1;
        while(bin >= lufs_b_gate && lra_cnt_hi < lra_cnt*0.05)
        (
          lra_cnt_hi += lufs_b_hist[bin];
          bin -= 1;
        );
        bin_hi=bin+1;
        lra_db_lo=bin_lo*DB_PER_BIN-70;
        lra_db_hi=bin_hi*DB_PER_BIN-70;
        lra_db_diff = lra_db_hi-lra_db_lo;
      );
    );
  ) : (
    lufs_s_db=-100;
  );
);

tp_l_db = hipk[0] > 0 ? 20.0 * log(hipk[0]) / log(10) : -200.0;
tp_r_db = num_ch > 1 && hipk[1] > 0 ? 20.0 * log(hipk[1]) / log(10) : -200.0;

// Phase correlation
corr_LR_sum += spl0 * spl1;
corr_LL_sum += spl0 * spl0;
corr_RR_sum += spl1 * spl1;

(corr_count += 1) > 50000 ? (
    corr_LR_sum *= 0.5;
    corr_LL_sum *= 0.5;
    corr_RR_sum *= 0.5;
    corr_count = 25000;
);

den = sqrt(corr_LL_sum * corr_RR_sum);
phase_correlation = den > 0 ? (corr_LR_sum / den) : 0;
phase_correlation = min(max(phase_correlation, -1), 1);

// Goniometer
gonio_buffer_L[gonio_pos] = spl0;
gonio_buffer_R[gonio_pos] = spl1;
gonio_pos += 1;
gonio_pos >= gonio_size ? gonio_pos = 0;

c=0;
loop
(
  num_ch,
  v=abs(spl(c))*mv;
  bat=0;
  v > 0.0 ? loop
  (
    64,
    nv=floor(v*0.5);
    nv*2.0 != v ? tbuf[bat] += dv;
    v=nv;
    bat += 1;
  );
  c += 1;
);

recpos[rec_write_pos]=(spl0+spl1);
rec_write_pos+=1;
reccnt+=1;
rec_write_pos >= histsize ? rec_write_pos=0;

// K-20 processing
k20_l.k20_process(spl0);
num_ch > 1 ? k20_r.k20_process(spl1);

//==================================================================================
// gfx section start
//==================================================================================

@gfx 1280 625

gfx_min_w = 987;
gfx_min_h = 538;
gfx_w < gfx_min_w ? gfx_w = gfx_min_w;
gfx_h < gfx_min_h ? gfx_h = gfx_min_h;

<? do_all_channels("ch%d.copypks(); ");?>;

t=time_precise();
speed = last_t ? 1.0-pow(0.5, (t-last_t)/LOUD_METER_SPEED) : 1;
last_t=t;

nch = cfg_mono ? 1 : max(num_ch,2);

// Font sizing like Cockos loudness meter
FONT_SZ_MIN = 12;
FONT_SZ_MAX = 22;
FONT_SZ_MIN_NORMAL = 10;
FONT_SZ_MAX_NORMAL = 18;

// Calculate font sizes based on window width (tuned for 18/14 at 1280 width)
fsz_title = FONT_SZ_MIN + min(gfx_w/213, FONT_SZ_MAX - FONT_SZ_MIN);  // 12 + 6 at 1280 = 18
fsz_normal = FONT_SZ_MIN_NORMAL + min(gfx_w/320, FONT_SZ_MAX_NORMAL - FONT_SZ_MIN_NORMAL);  // 10 + 4 at 1280 = 14

// Scale for retina
gfx_ext_retina > 1 ? (
  fsz_title *= 1.5;
  fsz_normal *= 1.5;
);

// Set fonts
gfx_setfont(1, "Arial", fsz_title);
font_normal = fsz_normal;

// Goniometer - scale with window size (percentage based)
gonio_x = gfx_w * 0.039;  // ~50 at 1280 width
gonio_y = gfx_h * 0.432;  // ~270 at 625 height
gonio_size_display = min(gfx_w * 0.141, gfx_h * 0.288);  // ~180 at default size, scales proportionally
gonio_half = gonio_size_display / 2;
// Scale factor must account for retina to prevent overflow
// gonio_scale = gonio_half * 0.95 / max(1, gfx_ext_retina);

//Clear text areas
gfx_r = 0; gfx_g = 0; gfx_b = 0;
gfx_rect(0, 0, gfx_w/2, gfx_h * 0.4);  // EBU section
gfx_rect(gfx_w/2 - gfx_w * 0.039, 0, gfx_w, gfx_h/2);  // Spectrum Analyzer


//Title
gfx_r = 0; gfx_g = 0.6; gfx_b = 1;
gfx_x = gfx_w*0.0202; gfx_y = 10;
gfx_drawstr("ReaVision Metering Suite");

gfx_setfont(1, "Arial", font_normal);

//LUFS Display
gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = gfx_w*0.0202; gfx_y = gfx_h*0.08;
gfx_drawstr("LUFS Integrated:");
gfx_x = gfx_w*0.1367;
sprintf(#str, "%.1f LUFS", lufs_i_db);
lufs_i_db > -100 ? (
gfx_drawstr(#str);
) : (
gfx_drawstr("---")
);

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = gfx_w*0.0202; gfx_y = gfx_h*0.128;
gfx_drawstr("LUFS Short-term:");
gfx_x = gfx_w*0.1367;
sprintf(#str, "%.1f LUFS", lufs_s_db);
lufs_s_db > -100 ? (
gfx_drawstr(#str);
) : (
gfx_drawstr("---")
);
gfx_x = gfx_w*0.225;
gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
sprintf(#str, "(max: %.1f)", -0.691+log(lufs_s_sum_max)*10/log(10));
gfx_drawstr(#str);

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = gfx_w*0.0202; gfx_y = gfx_h*0.176;
gfx_drawstr("LUFS Momentary:");
gfx_x = gfx_w*0.1367;
sprintf(#str, "%.1f LUFS", lufs_m_db);
lufs_m_db > -100 ? (
gfx_drawstr(#str);
) : (
gfx_drawstr("---")
);
gfx_x = gfx_w*0.225;
gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
sprintf(#str, "(max: %.1f)", -0.691+log(lufs_m_sum_max)*10/log(10));
gfx_drawstr(#str);

// LRA Display
gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = gfx_w*0.0202; gfx_y = gfx_h*0.224;
gfx_drawstr("Loudness Range:");
gfx_x = gfx_w*0.1367;
lra_db_diff > 0 ? (
  sprintf(#str, "%.1f LU", lra_db_diff+0.01);
  gfx_drawstr(#str);
) : (
  gfx_drawstr("---");
);

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = gfx_w*0.0202; gfx_y =  gfx_h*0.272;
gfx_drawstr("True Peak L:");
gfx_x = gfx_w*0.1367;
sprintf(#str, "%.2f dBTP", tp_l_db);
tp_l_db > -1 ? (gfx_r = 1; gfx_g = 0; gfx_b = 0;);
tp_l_db > -150 ? (
gfx_drawstr(#str);
) : (
gfx_drawstr("---")
);

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = gfx_w*0.0202; gfx_y = gfx_h*0.32;
gfx_drawstr("True Peak R:");
gfx_x = gfx_w*0.1367;
sprintf(#str, "%.2f dBTP", tp_r_db);
tp_r_db > -1 ? (gfx_r = 1; gfx_g = 0; gfx_b = 0;);
tp_r_db > -150 ? (
gfx_drawstr(#str);
) : (
gfx_drawstr("---")
);

// Fade for goniometer trail
gfx_r = 0; gfx_g = 0; gfx_b = 0;
gfx_a = 0.025;
gfx_circle(gonio_x + gonio_half, gonio_y + gonio_half, gonio_half+35, 1,0);
gfx_a = 1;

// Line width for retina
line_width = gfx_ext_retina > 1 ? 2 : 1;

gonio_pos > 0 ? (

gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.15;
gfx_circle(gonio_x + gonio_half, gonio_y + gonio_half, gonio_half, 0);

gfx_r = 0.3; gfx_g = 0.3; gfx_b = 0.3;
gfx_line(gonio_x + gonio_half*0.5, gonio_y + gonio_half*0.5,
         gonio_x + gonio_half*1.5, gonio_y + gonio_half*1.5);
gfx_line(gonio_x + gonio_half*0.5, gonio_y + gonio_half*1.5,
         gonio_x + gonio_half*1.5, gonio_y + gonio_half*0.5);

gfx_r = 0.25; gfx_g = 0.25; gfx_b = 0.25;
gfx_line(gonio_x + gonio_half, gonio_y, gonio_x + gonio_half, gonio_y + gonio_size_display);
gfx_line(gonio_x, gonio_y + gonio_half, gonio_x + gonio_size_display, gonio_y + gonio_half);

gfx_r = 0; gfx_g = 0.6; gfx_b = 1;
gfx_a = 0.6;
i = 0;
rot = -45 * 0.017453292;
samples_to_draw = gonio_pos;
loop(samples_to_draw,
  idx = i;
  L = gonio_buffer_L[idx];
  R = gonio_buffer_R[idx];

  // --- Normalize L and R to keep the plot inside bounding box ---
  peak = max(abs(L), abs(R));
  peak > 1 ? (L /= peak; R /= peak;);

  s0 = sign(L);
  s1 = sign(R);
  R != 0 ? angle = atan(L / R) : (L > 0 ? angle = 1.570796327 : angle = 4.71238898);
  (s0 == 1 && s1 == -1) || (s0 == -1 && s1 == -1) ? angle += 3.141592654;
  s0 == -1 && s1 == 1 ? angle += 6.283185307;
  L == 0 ? (R > 0 ? angle = 0 : angle = 3.141592654);

  radius = sqrt(L*L + R*R);
  angle -= rot;

  vert = cos(angle) * radius;
  horiz = sin(angle) * radius;

  plot_x = gonio_x + gonio_half + vert * gonio_half * 0.95;
  plot_y = gonio_y + gonio_half - horiz * gonio_half * 0.95;

  i > 0 ? (
    gfx_line(last_x, last_y, plot_x, plot_y);
  );

  last_x = plot_x;
  last_y = plot_y;

  i += 1;
);

gfx_a = 1;
gfx_r = 0.8; gfx_g = 0.8; gfx_b = 0.8;
gfx_x = gonio_x + gonio_half*0.3; gfx_y = gonio_y + gonio_half*0.4;
gfx_drawstr("L");
gfx_x = gonio_x + gonio_half*1.6; gfx_y = gonio_y + gonio_half*0.4;
gfx_drawstr("R");
// Center "M" label at top
gfx_measurestr("M", tw, th);
gfx_x = gonio_x + gonio_half - tw/2; gfx_y = gonio_y + gfx_h * 0.008;
gfx_drawstr("M");
gfx_x = gonio_x; gfx_y = gonio_y + gonio_half - gfx_h * 0.008;
gfx_drawstr(" +S");
gfx_x = gonio_x + gonio_size_display - gfx_w * 0.016; gfx_y = gonio_y + gonio_half - gfx_h * 0.008;
gfx_drawstr("-S");

gonio_pos = 0;

);

// Center "Goniometer" label
gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_measurestr("Goniometer", tw, th);
draw_text(gonio_x + gonio_half - tw/2, gonio_y + gonio_size_display + gfx_h * 0.016,"Goniometer");

// Phase Meter - scale with window size
phase_meter_x = gfx_w * 0.256;  // ~328 at 1280 width
phase_meter_y = gonio_y + gonio_half - phase_meter_h/2;;  // ~350 at 625 height
phase_meter_w = gfx_w * 0.195;  // ~250 at 1280 width
phase_meter_h = gfx_h * 0.048;  // ~30 at 625 height

gfx_r = 0.1; gfx_g = 0.1; gfx_b = 0.1;
gfx_rect(phase_meter_x, phase_meter_y, phase_meter_w, phase_meter_h);

gfx_r = 0.5; gfx_g = 0.5; gfx_b = 0.5;
gfx_line(phase_meter_x + phase_meter_w/2, phase_meter_y, phase_meter_x + phase_meter_w/2, phase_meter_y + phase_meter_h);

phase_pos = phase_meter_x + phase_meter_w/2 + (phase_correlation * phase_meter_w/2);
indicator_width = 4 * gfx_ext_retina;  // Scale indicator width for retina
phase_correlation < 0 ? (
  gfx_r = 1; gfx_g = 0.6; gfx_b = 0;
) : (
  gfx_r = 0; gfx_g = 0.6; gfx_b = 1;
);
gfx_rect(phase_pos - indicator_width/2, phase_meter_y, indicator_width, phase_meter_h);

gfx_r = 0.8; gfx_g = 0.8; gfx_b = 0.8;
draw_text(phase_meter_x,phase_meter_y + phase_meter_h + gfx_h * 0.008,"-1");
gfx_measurestr("+1", tw, th);
draw_text(phase_meter_x + phase_meter_w - tw, phase_meter_y + phase_meter_h + gfx_h * 0.008,"+1");
gfx_measurestr("0", tw, th);
draw_text(phase_meter_x + phase_meter_w/2 - tw/2, phase_meter_y + phase_meter_h + gfx_h * 0.008,"0");

// Center-align phase correlation label and value above meter
sprintf(#str, "%.3f", phase_correlation);
gfx_measurestr("Phase Correlation: ", label_w, th);
gfx_measurestr(#str, value_w, th);
total_w = label_w + value_w;
start_x = phase_meter_x + phase_meter_w/2 - total_w/2;

gfx_r = 1; gfx_g = 1; gfx_b = 1;
draw_text(start_x, phase_meter_y - gfx_h * 0.05, "Phase Correlation: ");
phase_correlation < 0 ? (gfx_r = 1; gfx_g = 0.5; gfx_b = 0;);
draw_text(start_x + label_w, phase_meter_y - gfx_h * 0.05, #str);


mtstart     = gfx_texth * 3;
mtrange     = gfx_w * 0.4;  // Proportional to width
mtvalstart  = gfx_h * 0.85;  // Proportional to height (85% down)
mtvalrange  = gfx_h * 0.6;   // Proportional to height
i = 0;
loop(65,
  x = mtstart + mtrange*(i-1)/64;
  y = mtvalstart;
  tick = !(i&7);
  tick ?
  (
    sprintf(#txt, "%d", i);
    gfx_measurestr(#txt, tw, th);
    gfx_r = 0; gfx_g = 0.6; gfx_b = 1;
    draw_text(x - tw*0.5, y + gfx_texth, #txt);
  );
  i > 0 ?
  (
    val = bbuf[64-i];
    val > 0.0 ?
    (
      gfx_r = 0; gfx_g = tick ? 1.0 : 0.625; gfx_b = 1;
    ) : (
      gfx_r = gfx_g = gfx_b = tick ? 0.75 : 0.5;
    );
    gfx_x = x;
    gfx_y = y;
    gfx_lineto(x, y - 2 - mtvalrange*0.1*val);
  );
  i += 1;
);
gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_setfont(1, "Arial", font_normal);
draw_text(mtstart + mtrange * 0.44, gfx_h * 0.93, "Bitmeter");  // Proportional label position

// ==================================================================================
// K-20 Meter
// ==================================================================================

k20_x = gfx_w * 0.36;  // Start at 1/3 of half width
k20_y = gfx_h * 0.06;   // Adjusted start position for taller meter
k20_w = gfx_w * 0.0625; // Half the original width
k20_h = gfx_h * 0.375;   // 1.5x the original height (was 0.32)

// Set smaller font for scale markings
gfx_ext_retina > 1 ? (
  gfx_setfont(2, "Arial", 14);
) : (
  gfx_setfont(2, "Arial", 9);   
);

gfx_measurestr("-60", label_w, label_h);
bg_padding = label_w + 8; 

gfx_r = 0; gfx_g = 0; gfx_b = 0;
gfx_rect(k20_x - bg_padding, k20_y - label_h, k20_w + bg_padding, k20_h + label_h * 2, 1);

k20_l_rms_db = k20_l.rms > 0 ? 20.0 * log(k20_l.rms) / log(10) : -100;
k20_r_rms_db = num_ch > 1 && k20_r.rms > 0 ? 20.0 * log(k20_r.rms) / log(10) : -100;

k20_l_peak_db = k20_l.peak > 0 ? 20.0 * log(k20_l.peak) / log(10) : -100;
k20_r_peak_db = k20_r.peak > 0 ? 20.0 * log(k20_r.peak) / log(10) : -100;

function dbfs_to_k20_y(dbfs, base_y, height) local(k20_value, normalized) (
  k20_value = dbfs + 20; 
  k20_value = max(-60, min(k20_value, 20)); 
  normalized = (k20_value + 60) / 80; 
  base_y + height * (1 - normalized)
);

zone_x = k20_x;
zone_w = k20_w * 0.55;  


green_top = dbfs_to_k20_y(-20, k20_y, k20_h);
green_bottom = k20_y + k20_h;
gfx_r = 0; gfx_g = 0.6; gfx_b = 0;
gfx_a = 0.3;
gfx_rect(zone_x, green_top, zone_w, green_bottom - green_top, 1);


yellow_top = dbfs_to_k20_y(-16, k20_y, k20_h);
yellow_bottom = green_top;
gfx_r = 0.8; gfx_g = 0.8; gfx_b = 0;
gfx_a = 0.3;
gfx_rect(zone_x, yellow_top, zone_w, yellow_bottom - yellow_top, 1);


red_top = k20_y;
red_bottom = yellow_top;
gfx_r = 0.8; gfx_g = 0; gfx_b = 0;
gfx_a = 0.3;
gfx_rect(zone_x, red_top, zone_w, red_bottom - red_top, 1);


gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
gfx_a = 1;

k20_marks = -60;
loop(9,
  dbfs_equiv = k20_marks - 20; 
  mark_y = dbfs_to_k20_y(dbfs_equiv, k20_y, k20_h);
  
  gfx_line(zone_x - 3, mark_y, zone_x, mark_y);  
  gfx_line(zone_x + zone_w, mark_y, zone_x + zone_w + 3, mark_y); 
  
  k20_marks == 0 ? (
    gfx_r = 1; gfx_g = 1; gfx_b = 0;
    sprintf(#k20_str, "0");
  ) : k20_marks > 0 ? (
    sprintf(#k20_str, "+%d", k20_marks);
  ) : (
    sprintf(#k20_str, "%d", k20_marks);
  );
  
  gfx_measurestr(#k20_str, tw, th);
  gfx_x = zone_x - tw - 5;
  gfx_y = mark_y - gfx_texth * 0.5;
  gfx_drawstr(#k20_str);
  
  gfx_x = zone_x + zone_w + 5;
  gfx_y = mark_y - gfx_texth * 0.5;
  gfx_drawstr(#k20_str);
  
  k20_marks == 0 ? (
    gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7; 
  );
  
  k20_marks += 10;
);

gfx_r = 0.5; gfx_g = 0.5; gfx_b = 0.5;
k20_marks = -55;
loop(8,
  dbfs_equiv = k20_marks - 20;
  mark_y = dbfs_to_k20_y(dbfs_equiv, k20_y, k20_h);

  gfx_line(zone_x - 2, mark_y, zone_x, mark_y);
  gfx_line(zone_x + zone_w, mark_y, zone_x + zone_w + 2, mark_y);
  k20_marks += 10;
);

gfx_setfont(1, "Arial", font_normal);

bar_w = zone_w * 0.4;
bar_spacing = zone_w * 0.1;

// Left channel RMS bar
k20_l_rms_db > -100 ? (
  bar_top = dbfs_to_k20_y(k20_l_rms_db, k20_y, k20_h);
  bar_height = k20_y + k20_h - bar_top;
  
  // Color based on K-20 zones
  k20_l_rms_db >= -16 ? (
    gfx_r = 1; gfx_g = 0; gfx_b = 0;  // Red (above +4 dB K-20)
  ) : k20_l_rms_db >= -20 ? (
    gfx_r = 1; gfx_g = 1; gfx_b = 0;  // Yellow (0 to +4 dB K-20)
  ) : (
    gfx_r = 0; gfx_g = 1; gfx_b = 0;  // Green (below 0 dB K-20)
  );
  gfx_a = 0.8;
  gfx_rect(zone_x + bar_spacing, bar_top, bar_w, bar_height, 1);
  
  // Peak indicator (colored to match zone)
  k20_l_peak_db > -100 ? (
    peak_y = dbfs_to_k20_y(k20_l_peak_db, k20_y, k20_h);
    k20_l_peak_db >= -16 ? (
      gfx_r = 1; gfx_g = 0; gfx_b = 0;  // Red
    ) : k20_l_peak_db >= -20 ? (
      gfx_r = 1; gfx_g = 1; gfx_b = 0;  // Yellow
    ) : (
      gfx_r = 0; gfx_g = 1; gfx_b = 0;  // Green
    );
    gfx_a = 0.9;
    gfx_rect(zone_x + bar_spacing, peak_y - 1, bar_w, 2, 1);
  );
);

// Right channel RMS bar
num_ch > 1 && k20_r_rms_db > -100 ? (
  bar_top = dbfs_to_k20_y(k20_r_rms_db, k20_y, k20_h);
  bar_height = k20_y + k20_h - bar_top;
  
  // Color based on K-20 zones
  k20_r_rms_db >= -16 ? (
    gfx_r = 1; gfx_g = 0; gfx_b = 0;  // Red (above +4 dB K-20)
  ) : k20_r_rms_db >= -20 ? (
    gfx_r = 1; gfx_g = 1; gfx_b = 0;  // Yellow (0 to +4 dB K-20)
  ) : (
    gfx_r = 0; gfx_g = 1; gfx_b = 0;  // Green (below 0 dB K-20)
  );
  gfx_a = 0.8;
  gfx_rect(zone_x + bar_spacing * 2 + bar_w, bar_top, bar_w, bar_height, 1);
  
  // Peak indicator (colored to match zone)
  k20_r_peak_db > -100 ? (
    peak_y = dbfs_to_k20_y(k20_r_peak_db, k20_y, k20_h);
    k20_r_peak_db >= -16 ? (
      gfx_r = 1; gfx_g = 0; gfx_b = 0;  // Red
    ) : k20_r_peak_db >= -20 ? (
      gfx_r = 1; gfx_g = 1; gfx_b = 0;  // Yellow
    ) : (
      gfx_r = 0; gfx_g = 1; gfx_b = 0;  // Green
    );
    gfx_a = 0.9;
    gfx_rect(zone_x + bar_spacing * 2 + bar_w, peak_y - 1, bar_w, 2, 1);
  );
);

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_measurestr("K-20", tw, th);
draw_text(zone_x + zone_w * 0.5 - tw * 0.5, k20_y - gfx_h * 0.032, "K-20");

// ==================================================================================
   gfx_ext_retina > 1 ? (
    gfx_setfont(1,"Arial",20,'b');
   ) : (
    gfx_setfont(1,"Arial",12,'b');
   );

  spectrum.bottom_margin = gfx_h/2;
  spectrum.left_margin = gfx_w/2+40;
  spectrum.top_margin = 20;
  spectrum.right_margin= 20;


Display_Mode < 2 ? (
  spectrum.draw(0);
  Spectrum_Mode == 3 || Spectrum_Mode == 6 ? spectrum.draw(1);
);

ht = (gfx_h/2 - spectrum.bottom_margin - gfx_texth) + 2;

dst_a = 0.55 / ht;
gfx_gradrect(0, ht/2, gfx_w, ht/2, 0,0,0,0,    0, 0, 0, 0, 0, 0, 0, dst_a*2); 

!((very_compact_width) | (very_compact_height)) ? (
  spectrum.draw_grid(0);
);

chr = gfx_getchar();

draw_info_panel(note_select);

note_select == 0 ? (
  draw_mouse_crosshair();
); 

!((very_compact_width) | (very_compact_height)) ? (
  
  gfx_ext_retina == 2 ? (peaks.x = gfx_w - 150; peaks.width = 100;) : (peaks.x = gfx_w - 100; peaks.width = 60;);
  gfx_ext_retina == 2 ? (mode_button.x = gfx_w - 400; mode_button.width = 120;) : (mode_button.x = gfx_w - 280; mode_button.width = 80;);
  gfx_ext_retina == 2 ? (channel_button.x = gfx_w - 280; channel_button.width = 120;) : (channel_button.x = gfx_w - 200; channel_button.width = 80;);
  mode_button.draw_mode_button();
  mode_button.handle_mode_button();
  // Only draw channel button if not in Full mode
  strcmp(mode_button.label, prev_mode_label) != 0 ? (
    strcmp(mode_button.label, "Mid/Side") == 0 ? (
      channel_button.label = "Mid+Side";
      Spectrum_Mode = 3;
   );
    strcmp(mode_button.label, "Left/Right") == 0 ? (
      channel_button.label = "Left+Right";
      Spectrum_Mode = 6;
    );
    // Update previous mode
    prev_mode_label = mode_button.label;
  );
  // Draw + handle channel button only if not Full mode
  strcmp(mode_button.label, "Full") != 0 ? (
      channel_button.draw_channel_button();
      channel_button.handle_channel_button(mode_button.label);
  );
  peaks.draw_peak_button();
  peaks.handle_peak_button();
);

//==================================================================================
// Spectrogram gfx
//==================================================================================

need_clear_spectro ? (
  need_clear_spectro = 0;
  cur_xpos = 0;
  
  // Clear the spectrogram area (bottom-right quadrant)
  gfx_r = gfx_g = gfx_b = 0;
  gfx_a = 1;
  gfx_x = gfx_w/2;
  gfx_y = gfx_h/2;
  gfx_rectto(gfx_w, gfx_h);
);

gfx_ext_retina>1 ? gfx_setfont(1,"Arial",16*gfx_ext_retina,'b') : gfx_setfont(0);

old_w != gfx_w || old_h!=gfx_h? (
  small_mode = gfx_w<200*gfx_ext_retina || gfx_h<200*gfx_ext_retina;
  cur_xpos=0;
  old_w=gfx_w; old_h=gfx_h;
  
  gfx_r=gfx_g=gfx_b=0; gfx_a=1;
  gfx_x=gfx_y=0;
  gfx_rectto(gfx_w,gfx_h);
  need_button_refs=1;
);

use_h = small_mode ? gfx_h : (gfx_h-gfx_texth - 4);

reccnt>0 ? (
    amt = min(reccnt,histsize*2);
    reccnt=0;
    drecpos = amt/pixels_per_frame;
    lrecpos = rec_write_pos - amt;
    draw_pos=0;

    loop(pixels_per_frame,

        windowsize != fftsize || windowtype != 2 ? (
            windowtype=2; 
            windowsize=fftsize;
            i=0;
            dwindowpos = $pi*2/fftsize;
            windowpos=0;
            pwr=0;
            loop(fftsize*.5+1,
                pwr += (window[i] =  (
                    windowtype==1 ? 0.53836 - cos(windowpos)*0.46164 :
                    windowtype==2 ? 0.35875 - 0.48829 * cos(windowpos) + 0.14128 * cos(2*windowpos) - 0.01168 * cos(3*windowpos) :
                    windowtype==3 ? 0.42 - 0.50 * cos(windowpos) + 0.08 * cos(2.0*windowpos) :
                    1.0));
                windowpos+=dwindowpos;
                i+=1;
            );
            pwr=1.0/(pwr*2-window[i-1]);
            loop(fftsize,window[i-=1]*=pwr; );
        );

        lrecpos += drecpos;

        buf1=(lrecpos|0)-fftsize;
        buf1<0 ? buf1+=histsize;
        buf2=window;
        buf3=fftworkspace;
        loop(fftsize*.5+1,
            buf3[] = recpos[buf1]*buf2[];
            buf3[1]=0;
            buf3+=2;

            buf2+=1;
            (buf1+=1) >= histsize ? buf1 -= histsize;
        );
        buf2-=1;
        loop(fftsize*.5-1,
            buf3[] = recpos[buf1]*(buf2-=1)[];
            buf3[1]=0;
            buf3+=2;

            (buf1+=1) >= histsize ? buf1 -= histsize;
        );
        fft(fftworkspace,fftsize);
        fft_permute(fftworkspace,fftsize);

        lfftpos=0;
        i=0;
        lscale=10/log(10);
        scroll=0;
        !(mouse_cap&1) || cap_mode>0 ? (
            scroll ? (
                gfx_a=1;
                cur_xpos = gfx_w/2 - 1 - pixels_per_frame + draw_pos;
                draw_pos==0 ? (
                    gfx_blit(
                        -1,
                        pixels_per_frame, 0,
                        pixels_per_frame, 0,
                        gfx_w/2 - pixels_per_frame + gfx_w/2,  // x offset into bottom-right
                        gfx_h/2,                                // y offset into bottom-right
                        0, 0,
                        gfx_w/2 - pixels_per_frame,
                        gfx_h/2
                    );
                ) : 0;
            ) : (
                // Fade mode: dark rectangle
                gfx_a = 0.1;
                gfx_r = gfx_g = gfx_b = 0 ;

                fade_width = 15;
                gfx_x = gfx_w/2 + cur_xpos; // bottom-right quadrant start
                gfx_y = gfx_h/2;            // vertical start

                end_x = gfx_x + fade_width;
                end_y = gfx_h;

                end_x > gfx_w ? end_x = gfx_w : 0;

                gfx_rectto(end_x, end_y);
            );

            uselm = islogmode;
            sc = (uselm ? (1.0/log(1+g_logscale)) : (1.0/(gfx_h/2-20))) * 0.5*fftsize;
            sc2=g_logscale/(gfx_h/2-20);

            loop(gfx_h/2-20,
                tpos = (uselm ? ((fftsize*0.5 - 1 - log(1+(gfx_h/2-20-1-i)*sc2)*sc)) : i*sc)|0;
                tpos >= fftsize*0.5 ? tpos=fftsize*0.5;
                lfftpos >= tpos ? ( lfftpos=tpos-1; );
                spectro_mv=0;

                loop(tpos-lfftpos,
                    usei = max(lfftpos,0)*2;
                    aa=fftworkspace[usei]; 
                    bb=fftworkspace[usei+1];
                    spectro_dv=aa*aa+bb*bb;
                    spectro_dv < 1.0*10^-20 ? spectro_dv = 1.0*10^-20 : 0;
                    spectro_dv>spectro_mv ? spectro_mv=spectro_dv;

                    lfftpos+=1;
                );
                spectro_mv=spectro_mv <= minvol ? -200 : log(spectro_mv)*lscale;

                // Draw pixels in bottom-right quadrant
                gfx_x = gfx_w/2 + cur_xpos;
                gfx_y = use_h - (i+1);  // bottom half
                gfx_a = 1;

                calc_color(spectro_mv, drawc);
                gfx_setpixel(drawc.r, drawc.g, drawc.b);

                i+=1;
            );

            cur_xpos+=1;
            cur_xpos >= gfx_w/2 - 15 ? cur_xpos=0;
            draw_pos+=1;
        );
    );
);

gfx_x=gfx_w/2;
gfx_y=use_h;
gfx_r=gfx_g=gfx_b=0;
gfx_a=1;
gfx_rectto(gfx_w,gfx_h);

mouse_x >= gfx_w/2 && mouse_x < gfx_w - 20 &&
mouse_y >= gfx_h/2 && mouse_y < gfx_h ? (
  !(mouse_cap&1) ? mb=-169;
  bla=0;
  loop(9,
    gfx_x=mouse_x - 1 + (bla%3); 
    gfx_y=mouse_y - 1 + (bla/3);
    gfx_getpixel(r,g,b); 

    r||g||b ? 
    ( 
      val = i = -169;
      bestdist = 10000000000;
      while (i<=0)
      (        
        calc_color(i,tmp);
        dist = sqr(tmp.r-r)+sqr(tmp.g-g)+sqr(tmp.b-b);
        dist < bestdist ? ( val=i; bestdist=dist; );
        i+=1;
      );
      mb = max(mb,val);
    );
    bla+=1;
  );
  (

  // Top and bottom of the spectrogram in pixels
  top_pixel    = gfx_h/2 - 20;
  bottom_pixel = use_h;
  // Clamp mouse_y to the visible spectrogram area
  clamped_y = max(top_pixel, min(mouse_y, bottom_pixel-1));
  // Compute pixel index (bottom-up, matches gfx_y = use_h - (i+1))
  i = bottom_pixel - 1 - clamped_y;
  // Map pixel index to FFT bin
  bin_index = i * (0.5 * fftsize) / (gfx_h/2-20);
  // Convert FFT bin to Hz
  converted_hz = bin_index * srate / fftsize;


    // converted_hz=(1-disp_hz)*srate*0.5;
    sprintf(#infostr,"%.0fHz",converted_hz);
    
    mb > -168 ? (
     sprintf(#infostr, "%s %.1fdB",#infostr,mb);
    ) : (
     #infostr += " -oodB";
    );
    
    gfx_measurestr(#infostr,wid,0);
    gfx_x=max((gfx_w-15)-wid,g_button_right_extent+4);
    gfx_y=use_h + 2;
    gfx_r=gfx_g=gfx_b=1;
    mouse_x > gfx_w/2 && mouse_y > (gfx_h/2) && converted_hz >= 0 ? (gfx_drawstr(#infostr));
  );
);

// Draw "Spectrograph" placeholder when no data
first_load == 1 ? (
  gfx_r = 0.3; gfx_g = 0.3; gfx_b = 0.3;
  gfx_a = 1;
  gfx_setfont(1, "Arial", font_normal);
  gfx_measurestr("Spectrograph", tw, th);
  gfx_x = gfx_w/2 + (gfx_w/2 - tw) / 2;  // Center in bottom-right quadrant
  gfx_y = gfx_h/2 + (gfx_h/2 - th) / 2;  // Center vertically
  draw_text(gfx_x, gfx_y, "Spectrograph");
  play_state != 0 ? first_load = 0;
);

//==================================================================================

has_click = (mouse_cap&1 && !last_cap) ? 1 : 0;
has_click && mouse_x < 375 && mouse_y < 225 ? Reset();
last_cap = mouse_cap;
