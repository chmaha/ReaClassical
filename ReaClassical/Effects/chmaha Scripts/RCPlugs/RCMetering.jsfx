NoIndex: true
desc:ReaClassical Metering Suite (chmaha)
author: chmaha
about:
  Released under GPLv3 license

slider1:Spectrum_Mode=0<0,5,1{Full,Mid,Side,Mid / Side,Left,Right,Left / Right}>-Spectrum
slider2:Display_Mode=0<0,2,1{Fill,Line,None}>-Display
slider3:Ceiling_Value=0<0,2,1{0dB,20dB,40dB}>-Ceiling
slider4:Floor_Value=0<0,2,1{-90dB,-140dB,-200dB}>-Floor
slider5:Tilt_Value=3<0,5,1{0dB/oct,1.5dB/oct,3dB/oct,4.5dB/oct,6dB/oct}>-Tilt
slider6:Type_Value=1<0,3,1{Hamming,Blackman-Harris,Blackman,Rectangular}>-Type
slider7:Block_Value=2<0,3,1{2048,4096,8192,16384}>-Block Size
slider8:Show_Piano=0<0,1,1{Off,On}>-Show Piano
slider8:Show_Peaks=0<0,1,1{Off,On}>-Show Peaks

import Dependencies/spectrum.jsfx-inc
import Dependencies/svf_filter.jsfx-inc

options:no_meter

@init

gfx_ext_retina  = 1;
ext_nodenorm    = 1;
ext_noinit = 1;
last_gfx_ext_retina = -1;

#VERSION = "RCPlugs";

spectrum.mem_index = 0;

/*
 * Round number up or down
 */
function round(in) (
  floor(in + 0.5 * sign(in));
);

/*
 * Standard log2
 */
function log2(x) ( 
  log(x) / log(2);
);

/*
 * Return string of integer
 */
function int2str(intIn) local (outStr) (
  strcpy(outStr=#,"");
  sprintf(outStr,"%d",intIn);
  outStr;
);

/*
 * Update the state of any changes
 */
function update_state() local (blocks) (
  spectrum.ceiling = Ceiling_Value == 0 ? 0 : Ceiling_Value == 1 ? 20 : Ceiling_Value == 2 ? 40;
  spectrum.noise_floor = Floor_Value == 0 ? -90 : Floor_Value == 1 ? -140 : Floor_Value == 2 ? -200;
  spectrum.noise_floor = Floor_Value == 0 ? -90 : Floor_Value == 1 ? -140 : Floor_Value == 2 ? -200;
  spectrum.tilt = Tilt_Value == 0 ? 0 : Tilt_Value == 1 ? 1.5 : Tilt_Value == 2 ? 3 : Tilt_Value == 3 ? 4.5 :
                  Tilt_Value == 4 ? 6;

  spectrum.windowtype != Type_Value+1 ? spectrum.set_type(Type_Value+1);

  blocks = (2 ^ (Block_Value+1)) * 1024;

  spectrum.windowsize != blocks ? spectrum.set_block_size(blocks);

  Display_Mode == 0 ? (
    fill_r = 0 / 255;
    fill_g = 153 / 255;
    fill_b = 255 / 255;
    fill_a = 0.5;
    spectrum.set_fill(0, 1);
    spectrum.set_color(0, fill_r, fill_g, fill_b, fill_a);
    fill_r =  0 / 255;
    fill_g = 255 / 255;
    fill_b = 255 / 255;
    fill_a = 0.5;
    spectrum.set_fill(1, 1); 
    spectrum.set_color(1, fill_r, fill_g, fill_b, fill_a);
  ) : Display_Mode == 1 ? (
    line_a=1.0;
    line_r = 0 / 255; line_g = 153 / 255; line_b = 255 / 255;;
    spectrum.set_fill(0, 0);
    spectrum.set_color(0, line_r, line_g, line_b, line_a);
    line_r = 253 / 255; line_g = 185 / 255; line_b = 21 / 255;;
    spectrum.set_fill(1, 0);
    spectrum.set_color(1, line_r, line_g, line_b, line_a);
  );
);

/*
 * Draw a crosshair where the mouse is
 */
function draw_mouse_crosshair() (
  mouse_x >= 0 && mouse_x > gfx_w/2 && mouse_y >=0 && mouse_y < gfx_h/2 ? (
    gfx_set(1.0, 1.0, 1.0, 0.3);
    gfx_line(gfx_w/2,mouse_y,gfx_w,mouse_y,1);
    gfx_line(mouse_x,0,mouse_x,gfx_h/2,1);
  );
);

/*
 * Draw a round cornered rectangle
 */
function draw_filled_rect(x, y, w, h, rad, alias) ( 
    gfx_circle(x+rad, y+rad, rad, 1, alias);
    gfx_circle(x+w-rad-1, y+rad, rad, 1, alias);
    gfx_circle(x+w-rad-1, y+h-rad-1, rad, 1, alias);
    gfx_circle(x+rad, y+h-rad-1, rad, 1, alias);

    gfx_rect(x, y+rad, rad*2, h-rad*2, alias);
    gfx_rect(x+w-rad*2, y+rad, rad*2, h-rad*2, alias);
    gfx_rect(x+rad, y, w-rad*2, rad*2, alias);
    gfx_rect(x+rad, y+h-rad*2, w-rad*2, rad*2, alias);

    gfx_rect(x+rad, y+rad, w-rad*2, h-rad*2, alias);
);

/*
 * Draw the info panel showing frequency, note, cent and dB
 */
function draw_info_panel(note_select)
  local(read_freq, read_amp, q, band, C0, semi, octave, note, cent, keys, nn, note_freq, centstr, width, xpos, xpos2, ypos)
 (
  mouse_x >= gfx_w/2 && mouse_x < gfx_w && mouse_y >= 0 && mouse_y < gfx_h/2 ? (
    gfx_set(0, 0.5, 1);
    read_freq = note_select == 0 ? spectrum.x_to_freq(mouse_x) : note_select;
    read_amp = spectrum.y_to_db(mouse_y);
    
    // Position in lower corner of upper right quadrant
    width = 130;
    gfx_ext_retina != 2 ? width -= 40;
    
    xpos = gfx_w/2 + 10;
    xpos2 = xpos + 55;
    gfx_ext_retina != 2 ? xpos2 -= 15;
    ypos = 20;  // Bottom of upper half, minus panel height and margin
    
    gfx_x = xpos;
    gfx_y = ypos;
    gfx_r = 0; gfx_g = 0; gfx_b = 0; gfx_a = 1.0;
    
    draw_filled_rect(gfx_x-5, gfx_y-5, width, gfx_texth*4, 8, 1);
    gfx_r = (0 / 255) * 0.5; gfx_g = (153 / 255) * 0.5; gfx_b = (255 / 255) * 0.5; gfx_a = 1.0;
    draw_filled_rect(gfx_x-10, gfx_y-10, width, gfx_texth*4, 8, 1);
    gfx_r = 114 / 255; gfx_g = 215 / 255; gfx_b = 253 / 255; gfx_a = 1.0;
    gfx_ext_retina != 2 ? gfx_y -= 8;
    
    read_freq < 100 ? ( gfx_drawstr(sprintf(#,"%.1f Hz", read_freq)) ) :
      (read_freq < 1000 ? ( gfx_drawstr(sprintf(#,"%.0f Hz", read_freq)) ) : ( 
        (read_freq < 10000 ? ( gfx_drawstr(sprintf(#,"%.2f kHz", read_freq/1000)) ) : ( 
          gfx_drawstr(sprintf(#,"%.1f kHz", read_freq/1000));
        )
      )
    ));
    
    // 440Hz is A4, get C0 as offset from that
    C0 = 440 * pow(2, -4.75);
    // Get seminotes (note number), octave and note within octave
    semi = round(12 * log2(read_freq / C0));
    octave = floor(semi / 12);
    note = (semi % 12);
    // Calculate cents
    note_freq = C0 * 2.71828 ^ (0.0577623 * semi);
    cent = floor(1200 * log2(read_freq / note_freq));
    // The above math goes a bit screwy for our -1 lowest octave.
    // We get a kind of inverse reflection.  This fixes it up.
    octave == -1 ? (
      note = (13 - (-(semi))) % 12;
      cent = -(99 - cent);
    );
    // Display it all
    keys="CCDDEFFGGAAB";
    strcpy_substr(nn=#,keys,note,1);
    note==1 || note==3 || note==6 || note==8 || note==10 ? strcat(nn,"#");
    strcat(nn, int2str(octave));
    cent < 0 ? strcpy(centstr=#,"-") : strcpy(centstr=#,"+");
    abs(cent) <= 9 ? strcat(centstr, "0");
    strcat(centstr, sprintf(#, "%d", abs(cent)));
    
    gfx_x = xpos;
    gfx_y += gfx_texth+2;
    gfx_drawstr(nn);
    gfx_x = xpos2;
    gfx_drawstr(centstr);
    gfx_x = xpos;
    gfx_y += gfx_texth+2;
    gfx_drawstr(sprintf(#,"%.1f DB", read_amp));
  );
);

/*
 * Draw the listener boundaries and set the Q for the bandpass filter
 */
function draw_listen_helper()
  local (mouse_spec, lread_freq, rread_freq, lfreq, rfreq, lx, rx, c0, lnsemi, lnoct, rnsemi, rnoct, oct)
(
  gfx_r = 114 / 255; gfx_g = 215 / 255; gfx_b = 253 / 255;

  listen_freq = spectrum.x_to_freq(mouse_x);

  mouse_spec = (mouse_x - spectrum.left_margin) / (gfx_w - spectrum.left_margin - spectrum.right_margin);

  lread_freq = spectrum.min_freq * exp(spectrum.freq_log_max * (mouse_spec - listen_width));
  rread_freq = spectrum.min_freq * exp(spectrum.freq_log_max * (mouse_spec + listen_width));

  lfreq = lread_freq;
  rfreq = rread_freq;

  lx = spectrum.freq_to_x(lfreq);
  rx = spectrum.freq_to_x(rfreq);

  c0 = 440.0 * 2.0 ^ (-57.0 / 12.0);    //C0 is 57 semitones below A4 (440 Hz)

  lnsemi = 12.0 * log(lfreq / c0) / log(2.0);
  lnoct = lnsemi / 12;           //Scientific pitch notation octave number

  rnsemi = 12.0 * log(rfreq / c0) / log(2.0);
  rnoct = rnsemi / 12;           //Scientific pitch notation octave number

  oct = rnoct - lnoct;

  listen_q = filter.svf_bwtoq(oct);

  gfx_a = 1.0;
  gfx_line(lx, 0, lx, gfx_h - gfx_texth+2);
  gfx_line(rx, 0, rx, gfx_h - gfx_texth+2);

  gfx_a = 0.8;
  gfx_line(lx-2, 0, lx-2, gfx_h - gfx_texth+2);
  gfx_line(rx+2, 0, rx+2, gfx_h - gfx_texth+2);

  gfx_a = 0.5;
  gfx_line(lx-4, 0, lx-4, gfx_h - gfx_texth+2);
  gfx_line(rx+4, 0, rx+4, gfx_h - gfx_texth+2);
);

/*
 * Initialise the peaks button
 */
function init_peak_button(xpos, ypos, buttonwidth) instance (x, y, width, label) (
  x = xpos;
  y = ypos;
  width = buttonwidth;
  label = "Peaks";
);

/*
 * Draw the peaks toggle button
 */
function draw_peak_button() instance (x, y, width, menutext, label, pressed, height, label) local(w, h, a) ( 
  mouse_x >= gfx_w/2 && mouse_x < gfx_w && mouse_y >= 0 && mouse_y < gfx_h/2 ? (
  gfx_a = 1;

  gfx_measurestr(label, w, h);

  height = h + 8;

  mouse_x >= x && mouse_x <= x+width && mouse_y >= y && mouse_y <= y + height ? ( 
    gfx_r = (0 / 255) * 0.6;
    gfx_g = (153 / 255) * 0.6;
    gfx_b = (255 / 255) * 0.6;
  ) : (
    Show_Peaks ? a = 0.6 : a = 0.4;
    gfx_r = (0 / 255) * a;
    gfx_g = (153 / 255) * a;
    gfx_b = (255 / 255) * a;
  );

  gfx_rect(x, y, width, h+9);

  gfx_circle(x, y + ((h+8)*0.5), ((h+8)*0.5), 1);
  gfx_circle(x + width, y + ((h+8)*0.5), ((h+8)*0.5), 1);

  Show_Peaks ? (
    gfx_r = (114 / 255);
    gfx_g = (215 / 255);
    gfx_b = (253 / 255);
  ) : ( 
    gfx_r = (114 / 300);
    gfx_g = (215 / 300);
    gfx_b = (253 / 300);    
  );
  gfx_a = 1;
  gfx_x = x + (width / 2) - (w / 2);
  gfx_y = y + 4;
  gfx_drawstr(label);
  );
);

/*
 * Handle clicking the peaks button
 */
function handle_peak_button() instance (x, y, width, label, pressed, height, label)
  local (last_clicked_item)
(
  last_clicked_item = 0;
  mouse_cap & 1 && !pressed ? (
    mouse_x >= x && mouse_x <= x+width && mouse_y >= y && mouse_y <= y + height ? ( 
      pressed = 1;

      Show_Peaks = Show_Peaks ? Show_Peaks = 0 : 1;

      spectrum.set_show_peaks(Show_Peaks);

    ) : pressed = 0;
  ) : ( 
    !(mouse_cap & 1) ? pressed = 0;
  );
);


/*
 * Initialise the analyzer options button
 */
function init_menu_button(xpos, ypos, buttonwidth, buttonlabel, menutext) instance (x, y, width, menutext, label) (
  x = xpos;
  y = ypos;
  width = buttonwidth;
  this.menutext = menutext;
  label = buttonlabel;
);

/*
 * Draw the analyzer options button
 */
function draw_menu_button() instance (x, y, width, menutext, label, pressed, height, label) ( 
  mouse_x >= gfx_w/2 && mouse_x < gfx_w && mouse_y >= 0 && mouse_y < gfx_h/2 ? (
  gfx_a = 1;

  gfx_measurestr(label, w, h);

  height = h + 8;

  mouse_x >= x && mouse_x <= x+width && mouse_y >= y && mouse_y <= y + height ? ( 
    gfx_r = (0 / 255) * 0.6;
    gfx_g = (153 / 255) * 0.6;
    gfx_b = (255 / 255) * 0.6;
  ) : (
    gfx_r = (0 / 255) * 0.4;
    gfx_g = (153 / 255) * 0.4;
    gfx_b = (255 / 255) * 0.4;
  );

  gfx_rect(x, y, width, h+9);

  gfx_circle(x, y + ((h+8)*0.5), ((h+8)*0.5), 1);
  gfx_circle(x + width, y + ((h+8)*0.5), ((h+8)*0.5), 1);

  gfx_r = (114 / 255);
  gfx_g = (215 / 255);
  gfx_b = (253 / 255);
  gfx_a = 1;
  gfx_x = x + (width / 2) - (w / 2);
  gfx_y = y + 4;
  gfx_drawstr(label);
  );
);

/*
 * Handle the analyzer options button
 */
function handle_menu_button() instance (x, y, width, menutext, label, pressed, height, label)
  local (last_clicked_item)
(
  last_clicked_item = 0;
  mouse_cap & 1 && !pressed ? (
    mouse_x >= x && mouse_x <= x+width && mouse_y >= y && mouse_y <= y + height ? ( 
      pressed = 1;

        #menu = "#Version: ";
        #menu += #VERSION;
        #menu += " ||";

        #menu += ">Spectrum|";
        Spectrum_Mode == 0 ? #menu += "!"; #menu += "Full|";
        Spectrum_Mode == 1 ? #menu += "!"; #menu += "Mid|";
        Spectrum_Mode == 2 ? #menu += "!"; #menu += "Side|";
        Spectrum_Mode == 3 ? #menu += "!"; #menu += "Mid + Side|";
        Spectrum_Mode == 4 ? #menu += "!"; #menu += "Left|";
        Spectrum_Mode == 5 ? #menu += "!"; #menu += "Right|";
        Spectrum_Mode == 6 ? #menu += "!"; #menu += "<Left + Right|";

        #menu += ">Display|";
        Display_Mode == 0 ? #menu += "!"; #menu += "Fill|";
        Display_Mode == 1 ? #menu += "!"; #menu += "Line|";
        Display_Mode == 2 ? #menu += "!"; #menu += "<None|";

        #menu += ">Range|";
        Ceiling_Value == 0 ? #menu += "!"; #menu += "Ceiling 0dB|";
        Ceiling_Value == 1 ? #menu += "!"; #menu += "Ceiling 20dB|";
        Ceiling_Value == 2 ? #menu += "!"; #menu += "Ceiling 40dB||";
        Floor_Value == 0 ? #menu += "!"; #menu += "Floor -90dB|";
        Floor_Value == 1 ? #menu += "!"; #menu += "Floor -140dB|";
        Floor_Value == 2 ? #menu += "!"; #menu += "<Floor -200dB|";

        #menu += ">Tilt|";
        Tilt_Value == 0 ? #menu += "!"; #menu += "0dB/oct|";
        Tilt_Value == 1 ? #menu += "!"; #menu += "1.5dB/oct|";
        Tilt_Value == 2 ? #menu += "!"; #menu += "3dB/oct|";
        Tilt_Value == 3 ? #menu += "!"; #menu += "4.5dB/oct|";
        Tilt_Value == 4 ? #menu += "!"; #menu += "<6dB/oct|";

        #menu += ">Window Type|";
        Type_Value == 0 ? #menu += "!"; #menu += "Hamming|";
        Type_Value == 1 ? #menu += "!"; #menu += "Blackman-Harris|";
        Type_Value == 2 ? #menu += "!"; #menu += "Blackman|";
        Type_Value == 3 ? #menu += "!"; #menu += "<Rectangular|";

        #menu += ">FFT Size|";
        Block_Value == 0 ? #menu += "!"; #menu += "2048|";
        Block_Value == 1 ? #menu += "!"; #menu += "4096|";
        Block_Value == 2 ? #menu += "!"; #menu += "8192|";
        Block_Value == 3 ? #menu += "!"; #menu += "16384|";

      gfx_x = mouse_x;
      gfx_y = mouse_y;

      last_clicked_item = gfx_showmenu(#menu) - 1;

      pressed = 0;

      last_clicked_item >= 1 && last_clicked_item <= 7 ? (
        // Force reset of peak buffers
        spectrum.set_show_peaks(Show_Peaks);

        Spectrum_Mode = last_clicked_item - 1;
      );

      last_clicked_item >= 8 && last_clicked_item <= 10 ? ( 
        Display_Mode = last_clicked_item - 8;
      );

      last_clicked_item >= 11 && last_clicked_item <= 13 ? ( 
        Ceiling_Value = last_clicked_item - 11;
      );

      last_clicked_item >= 14 && last_clicked_item <= 16 ? ( 
        Floor_Value = last_clicked_item - 14;
      );

      last_clicked_item >= 17 && last_clicked_item <= 21 ? ( 
        Tilt_Value = last_clicked_item - 17;
      );

      last_clicked_item >= 22 && last_clicked_item <= 25 ? ( 
        Type_Value = last_clicked_item - 22;
      );

      last_clicked_item >= 26 && last_clicked_item <= 29 ? ( 
        Block_Value = last_clicked_item - 26;
      );

      last_clicked_item >= 1 ? update_state();
    ) : pressed = 0;
  ) : ( 
    !(mouse_cap & 1) ? pressed = 0;
  );

  last_clicked_item;
);

/*
 * Set global state vars
 */

do_listen = 0;
listen_width = 0.10;

filter.svf_set_sample_rate(srate);

gfx_ext_retina == 2 ? (
  menu.init_menu_button(gfx_w - 140, 10, 120, "Settings", "");
  peaks.init_peak_button(gfx_w - 420, 10, 100);
) : ( 
  menu.init_menu_button(gfx_w - 140, 10, 80, "Settings", "");
  peaks.init_peak_button(gfx_w - 420, 10, 60);
);

spectrum.set_show_peaks(Show_Peaks);

<?
  nch = max(max_nch,64); // maximum channel count
  sinc_sz = 32; // true peak interpolation size
  use_mem_sinc = sinc_sz>32;

  printf("sinc_sz = %d;\n",sinc_sz);

 function do_all_channels(fmt) local(p x c) global(nch) (
   p=x=0;
   while (x < nch) (
     p+=1;
     x>0 ? printf("num_ch > %d ? ( ",x);
     c = x>=24 ? 8 : x>=8 ? 4 : 2;
     loop(c, printf(fmt,x,x); x+=1);
     printf("\n");
   );
   loop(p-1,printf(")"));
 );
?>

// Constants
WANT_INTEGRATED_ALWAYS=0;
PEAK_METER_DECAY=0.150;
LOUD_METER_UPDATE=0.100;
LOUD_METER_SPEED=0.075;
NUM_BINS=1024;
BINS_PER_DB=10;
DB_PER_BIN=1/BINS_PER_DB;
cfg_peak = 1;
ext_noinit=1;
gfx_clear=-1;
ext_nodenorm=1;
cfg_reinit=1;
attackms=50.0;
decayms=300.0;
mv=pow(2,63);

// Memory allocation
function alloc(sz) (
  memset((alloc.top += sz) - sz, 0, sz);
);

function alloc(sz) global()
(
  memset((this.top+=sz)-sz,0,sz);
);

// sinc filter for true peak
function sinc_gen_val() global(srate sinc_sz) local(sincpos windowpos) instance(slice_pos) (
  windowpos = (2.0 * $pi / sinc_sz) * slice_pos;
  sincpos = $pi * (slice_pos - sinc_sz * .5);
  slice_pos += 1;
  (0.53836 - cos(windowpos)*0.46164) * sin(sincpos) / sincpos;
);

function sinc_gen_slice(cs, o*) instance(sinc_gen_val slice_pos) local(x) global(sinc_sz) (
  slice_pos = cs;
<?
  use_mem_sinc ? (
    printf("o.v = alloc(sinc_sz);  loop(x=0;sinc_sz, o.v[x] = sinc_gen_val(); x+=1); ");
  ) : (
    loop(x=0;sinc_sz, printf("o.v%02d = sinc_gen_val();%s",x,(x&3)==3?"\n": " "); x += 1)
  );
?>
);

function sinc_init() global(srate) instance(sinc_gen_slice) (
  sinc_gen_slice(srate < 96000 ? .25 : .5,this.s1);
  srate < 96000 ? (
    sinc_gen_slice(.5, this.s2);
    sinc_gen_slice(.75, this.s3);
  );
);

<?
 function emit_sinc(hist, t) (
   use_mem_sinc ? (
    printf("abs(mem_multiply_sum(%s.v,%s.h,sinc_sz))",t,hist);
   ) : (
     printf("abs(");
     loop(x=0;sinc_sz, printf("%s.h%02d * %s.v%02d%s",hist,x,t,x,x==sinc_sz-1?"":(x&3)==3?" +\n":" + "); x+=1);
     printf(")");
   );
 );
?>

function init(chidx)
(
  this.chan=chidx;
  this.wt = chidx < 3 || num_ch < 6 ? 1 : chidx == 3 ? 0 : sqrt(2);
  this.f1p1=this.f1p2=this.f2p1=this.f2p2=0;
  this.pkval=this.hipkval=this.clips=0;
  this.ch_lufs_sum=this.ch_rms_sum=0;
  <?
    use_mem_sinc ? (
      printf("this.h = alloc(sinc_sz);\n");
    ) : (
      loop(x=0;sinc_sz, printf("this.h%02d =%s",x,x==sinc_sz-1 ? " 0" : (x&7)==7 ? "\n" : " "); x+=1);
    );
  ?>
);

function decay()
(
  this.pkval *= pk_decay;
);

function copypks() global(pk hipk clip_cnt) (
  pk[this.chan] = this.pkval;
  hipk[this.chan] = this.hipkval;
  clip_cnt[this.chan] = this.clips;
);

function proc(lspl)
  local(pspl f1p0 f2p0)
  instance(wt ch_rms_sum ch_lufs_sum pkval hipkval clips
           f1p1 f1p2 f2p1 f2p2)
  global(f1a1 f1a2 f1b0 f1b1 f1b2
         f2a1 f2a2 f2b0 f2b1 f2b2
         srate cfg_peak
         lval rval win_pos global_peak sinc_sz
         sinc.s1* sinc.s2* sinc.s3*
         )
(
  cfg_peak == 1 || cfg_peak == 2 ? (
    <?
      use_mem_sinc ? (
        printf("mem_insert_shuffle(this.h, sinc_sz, lspl);");
      ) : (
        loop(x=sinc_sz-1;sinc_sz-1, printf("this.h%02d = this.h%02d;%s",x,x-1, (x&3)==0 ? "\n" : " "); x-= 1; );
        printf(" this.h00 = lspl;");
      );
    ?>
    pspl = max(
        abs(this.h<? printf(use_mem_sinc ? "[%d]" : "%02d",sinc_sz/2) ?> ),
        <? emit_sinc("this","sinc.s1") ?>
       );
    srate < 96000 ? pspl = max(pspl,max( <? emit_sinc("this","sinc.s2") ?>,  <? emit_sinc("this","sinc.s3") ?>));
  ) :
  cfg_peak == 3 || cfg_peak == 4 ? (
    pspl=abs(lspl);
  );
  cfg_peak ? (
    pspl > pkval ? (
      pkval=pspl;
      pspl > hipkval ? (
        hipkval=pspl;
        global_peak = max(global_peak,pspl);
      );
    );
    pspl > 1.0 ? clips += 1;
  );

  win_pos == 0 ? ch_rms_sum=ch_lufs_sum=0;

  rval += (ch_rms_sum += lspl*lspl);

  lspl *= wt;

  f1p0=lspl-f1a1*f1p1-f1a2*f1p2;
  lspl=f1b0*f1p0+f1b1*f1p1+f1b2*f1p2;
  f1p2=f1p1;
  f1p1=f1p0;

  f2p0=lspl-f2a1*f2p1-f2a2*f2p2;
  lspl=f2b0*f2p0+f2b1*f2p1+f2b2*f2p2;
  f2p2=f2p1;
  f2p1=f2p0;

  lval += (ch_lufs_sum += lspl*lspl);
);

function init_lufs_filters()
  local(Vh Vb db f0 Q K a0)
  global(f1a1 f1a2 f1b0 f1b1 f1b2
         f2a1 f2a2 f2b0 f2b1 f2b2 srate)
(
  // f1,f2 could be combined into a 5th order filter

  db=3.999843853973347;
  f0=1681.974450955533;
  Q=0.7071752369554196;
  K=tan($pi*f0/srate);
  Vh=pow(10, db/20);
  Vb=pow(Vh, 0.4996667741545416);
  a0=1+K/Q+K*K;
  f1a1=2*(K*K-1)/a0;
  f1a2=(1-K/Q+K*K)/a0;
  f1b0=(Vh+Vb*K/Q+K*K)/a0;
  f1b1=2*(K*K-Vh)/a0;
  f1b2=(Vh-Vb*K/Q+K*K)/a0;

  f0=38.13547087602444;
  Q=0.5003270373238773;
  K=tan($pi*f0/srate);
  f2a1=2*(K*K-1)/(1+K/Q+K*K);
  f2a2=(1-K/Q+K*K)/(1+K/Q+K*K);
  f2b0=1;
  f2b1=-2;
  f2b2=1;
);

spectrum.init();
spectrum_mem_end = spectrum.mem_index; 

function Reset() (
init_lufs_filters();

  alloc.top = spectrum_mem_end;
  pk=alloc(<?printf("%d",nch)?>);
  hipk=alloc(<?printf("%d",nch)?>);
  clip_cnt=alloc(<?printf("%d",nch)?>);
  sinc.sinc_init();

  m_win_cnt=0.4/LOUD_METER_UPDATE;
  s_win_cnt=3/LOUD_METER_UPDATE;

  win_pos=0;
  win_cnt=0;
  win_len=(LOUD_METER_UPDATE*srate)|0;
  i_win_len=1/(m_win_cnt*win_len);
  i_win_len2=1/(s_win_cnt*win_len);

  rms_m_sum=0;
  rms_m_db=-100;
  rms_m_db_max=-100;
  rms_i_sum=0;
  rms_i_sum_cnt=0;
  rms_i_db=-100;

  lufs_m_sum=0;
  lufs_m_sum_max=0;
  lufs_m_db=-100;
  lufs_s_sum=0;
  lufs_s_sum_max=0;
  lufs_s_db=-100;
  lufs_a_sum=0;
  lufs_a_sum_cnt=0;
  lufs_b_sum=0;
  lufs_b_sum_cnt=0;
  lra_db_diff = 0;
  lra_db_hi = lra_db_lo = lufs_i_db = lufs_m_db = lufs_s_db = -100;

  last_t=0;
  th_lufs_i=th_lufs_s=th_lufs_m=th_rms_i=th_rms_m=0;

  cur_buf=0;
  cur_buf2=0;
  rms_buf=alloc(m_win_cnt);
  lufs_buf=alloc(m_win_cnt);
  lufs_buf2=alloc(s_win_cnt);
  lufs_a_hist=alloc(2*NUM_BINS);
  lufs_b_hist=alloc(NUM_BINS);
  db_hist=alloc(75);
  db_hist_max=0;

  global_peak = 0;

  <? do_all_channels("ch%d.init(%d); "); ?>;

  gonio_size = 4800;
  gonio_buffer_L = alloc(gonio_size);
  gonio_buffer_R = alloc(gonio_size);
  gonio_pos = 0;

  corr_LR_sum = 0;
  corr_LL_sum = 0;
  corr_RR_sum = 0;
  corr_count = 0;

bitbuf_len = 64;

bbuf = alloc(bitbuf_len);
tbuf = alloc(bitbuf_len);

memset(bbuf, 0, bitbuf_len);
memset(tbuf, 0, bitbuf_len);

);

Reset();

@slider

update_state();

@block
(num_ch > 0 && num_ch != last_nch) || srate != last_sr ? Reset();
last_nch = num_ch;
last_sr = srate;

cfg_reinit && (play_state&1) ? (
  abs(play_position-last_play_pos) > 0.1 ? Reset();
  last_play_pos=play_position+samplesblock/srate;
);

pk_decay=pow(0.5, samplesblock/srate/PEAK_METER_DECAY);

<? do_all_channels("ch%d.decay(); "); ?>;

dv=1.0/(sqrt(num_ch)*samplesblock);
attack=exp(-log(2.0)*samplesblock/(srate*attackms*0.001));
decay=exp(-log(2.0)*samplesblock/(srate*decayms*0.001));

bat=0;
loop
(
  64,
  bbuf[bat] *= decay;
  v=sqrt(min(tbuf[bat],1.0));
  v > bbuf[bat] ?
  (
    bbuf[bat]=bbuf[bat]*attack+v*(1.0-attack);
  ) : (
    bbuf[bat] < 0.001 ? bbuf[bat]=0.0;
  );
  tbuf[bat]=0.0;
  bat += 1;
);

@sample

// Mid/Side encode
mid = (spl0 + spl1) * 0.5;
side = (spl0 - spl1) * 0.5;

// Feed the correct buffers depending on spectrum modes
Spectrum_Mode == 0 ? spectrum.sample0(spl0 + spl1) :
Spectrum_Mode == 1 ? spectrum.sample0(mid) :
Spectrum_Mode == 2 ? spectrum.sample0(side) :
Spectrum_Mode == 3 ? (spectrum.sample0(mid); spectrum.sample1(side)) :
Spectrum_Mode == 4 ? spectrum.sample0(spl0) :
Spectrum_Mode == 5 ? spectrum.sample0(spl1) :
Spectrum_Mode == 6 ? (spectrum.sample0(spl0); spectrum.sample1(spl1));

// Filter if we're in listen mode
do_listen ? (
  mono = 0.5 * (spl0 + spl1);
  filter.svf_bp2(listen_freq, listen_q);
  spl0 = spl1 = filter.svf_svf0(mono); 
);

rval=lval=0;

<? do_all_channels("ch%d.proc(spl%d); "); ?>;

(win_pos += 1) >= win_len ? (
  win_pos=0;
  win_cnt += 1;

  prev_rval=rms_buf[cur_buf];
  rms_buf[cur_buf]=rval;

  prev_lval=lufs_buf[cur_buf];
  lufs_buf[cur_buf]=lval;

  prev_lval2=lufs_buf2[cur_buf2];
  lufs_buf2[cur_buf2]=lval;

  (cur_buf += 1) >= m_win_cnt ? cur_buf=0;
  (cur_buf2 += 1) >= s_win_cnt ? cur_buf2=0;

  rms_m_sum += (rval-prev_rval)*i_win_len;
  lufs_m_sum += (lval-prev_lval)*i_win_len;
  lufs_s_sum += (lval-prev_lval2)*i_win_len2;

  WANT_INTEGRATED_ALWAYS || (play_state&1) ? (
    rms_i_sum += rms_m_sum;
    rms_i_sum_cnt += 1;
    rms_i_sum > 0 && rms_i_sum_cnt >= m_win_cnt ? (
      rms_i_db=log(rms_i_sum/rms_i_sum_cnt)*10/log(10);
    ) : (
      rms_i_db=-100;
    );
  );

  rms_m_sum > 0 && win_cnt >= m_win_cnt ? (
    rms_m_db=log(rms_m_sum)*10/log(10);
    rms_m_db > rms_m_db_max ? rms_m_db_max=rms_m_db;
  ) : (
    rms_m_db=-100;
  );

  lufs_m_sum > 0 && win_cnt >= m_win_cnt ? (
    lufs_m_sum > lufs_m_sum_max ? lufs_m_sum_max=lufs_m_sum;
    lufs_m_db=-0.691+log(lufs_m_sum)*10/log(10);

    a = WANT_INTEGRATED_ALWAYS || (play_state&1) ? ((lufs_m_db+70)*BINS_PER_DB)|0 : -1;
    a >= 0 ? (
      a >= NUM_BINS ? a=NUM_BINS-1;
      lufs_a_sum += lufs_m_sum;
      lufs_a_sum_cnt += 1;
      lufs_a_hist[2*a] += 1;
      lufs_a_hist[2*a+1] += lufs_m_sum;
      db_hist_max = max(db_hist_max,db_hist[min(a*DB_PER_BIN,74)] += 1);

      lufs_a_db=-0.691+log(lufs_a_sum/lufs_a_sum_cnt)*10/log(10);
      lufs_a_gate=((lufs_a_db-10+70)*BINS_PER_DB)|0;
      lufs_i_sum=0;
      lufs_i_cnt=0;
      bin=max(lufs_a_gate,0);
      loop(NUM_BINS-bin,
        lufs_i_cnt += lufs_a_hist[2*bin];
        lufs_i_sum += lufs_a_hist[2*bin+1];
        bin += 1;
      );
      lufs_i_db=lufs_i_sum > 0 ? -0.691+log(lufs_i_sum/lufs_i_cnt)*10/log(10) : -100;
    );
  ) : (
    lufs_m_db=-100;
  );

  lufs_s_sum > 0 && win_cnt >= s_win_cnt ? (
    lufs_s_sum > lufs_s_sum_max ? lufs_s_sum_max=lufs_s_sum;
    lufs_s_db=-0.691+log(lufs_s_sum)*10/log(10);

    b = WANT_INTEGRATED_ALWAYS || (play_state&1) ? ((lufs_s_db+70)*BINS_PER_DB)|0 : -1;
    b >= 0 ? (
      b >= NUM_BINS ? b=NUM_BINS-1;
      lufs_b_sum += lufs_s_sum;
      lufs_b_sum_cnt += 1;
      lufs_b_hist[b] += 1;

      lufs_b_db=-0.691+log(lufs_b_sum/lufs_b_sum_cnt)*10/log(10);
      lufs_b_gate=((lufs_b_db-20+70)*BINS_PER_DB)|0;

      lra_cnt=0;
      bin=max(lufs_b_gate,0);
      loop(NUM_BINS-bin,
        lra_cnt += lufs_b_hist[bin];
        bin += 1;
      );
      lra_cnt >= 20 ? (
        lra_cnt_lo=lra_cnt_hi=0;
        bin=lufs_b_gate;
        while(bin < NUM_BINS && lra_cnt_lo < lra_cnt*0.10)
        (
          lra_cnt_lo += lufs_b_hist[bin];
          bin += 1;
        );
        bin_lo=bin-1;
        bin=NUM_BINS-1;
        while(bin >= lufs_b_gate && lra_cnt_hi < lra_cnt*0.05)
        (
          lra_cnt_hi += lufs_b_hist[bin];
          bin -= 1;
        );
        bin_hi=bin+1;
        lra_db_lo=bin_lo*DB_PER_BIN-70;
        lra_db_hi=bin_hi*DB_PER_BIN-70;
        lra_db_diff = lra_db_hi-lra_db_lo;
      );
    );
  ) : (
    lufs_s_db=-100;
  );
);

tp_l_db = hipk[0] > 0 ? 20.0 * log(hipk[0]) / log(10) : -200.0;
tp_r_db = num_ch > 1 && hipk[1] > 0 ? 20.0 * log(hipk[1]) / log(10) : -200.0;

// Phase correlation
corr_LR_sum += spl0 * spl1;
corr_LL_sum += spl0 * spl0;
corr_RR_sum += spl1 * spl1;

(corr_count += 1) > 50000 ? (
    corr_LR_sum *= 0.5;
    corr_LL_sum *= 0.5;
    corr_RR_sum *= 0.5;
    corr_count = 25000;
);

den = sqrt(corr_LL_sum * corr_RR_sum);
phase_correlation = den > 0 ? (corr_LR_sum / den) : 0;
phase_correlation = min(max(phase_correlation, -1), 1);

// Goniometer
gonio_buffer_L[gonio_pos] = spl0;
gonio_buffer_R[gonio_pos] = spl1;
gonio_pos += 1;
gonio_pos >= gonio_size ? gonio_pos = 0;

c=0;
loop
(
  num_ch,
  v=abs(spl(c))*mv;
  bat=0;
  v > 0.0 ? loop
  (
    64,
    nv=floor(v*0.5);
    nv*2.0 != v ? tbuf[bat] += dv;
    v=nv;
    bat += 1;
  );
  c += 1;
);

@gfx 1280 625
gfx_w != 1280 || gfx_h != 625 ? (
  gfx_w = 1280;
  gfx_h = 625;
);

<? do_all_channels("ch%d.copypks(); ");?>;

t=time_precise();
speed = last_t ? 1.0-pow(0.5, (t-last_t)/LOUD_METER_SPEED) : 1;
last_t=t;

nch = cfg_mono ? 1 : max(num_ch,2);

// Fade for goniometer trail
gfx_r = 0; gfx_g = 0; gfx_b = 0;
gfx_a = 0.025;
gfx_x = 0; gfx_y = 0;
gfx_rectto(gfx_w, gfx_h);
gfx_a = 1;

// Clear text areas
gfx_r = 0; gfx_g = 0; gfx_b = 0;
gfx_rect(0, 0, gfx_w, 260);
gfx_rect(335, 295, 225, 30);
gfx_r = 0; gfx_g = 0; gfx_b = 0;
gfx_rect(320, 385, 260, 20);
gfx_rect(0, 455, gfx_w, gfx_h);
gfx_rect(320, 0, gfx_w, gfx_h);

// Title
gfx_r = 0; gfx_g = 0.6; gfx_b = 1;
gfx_x = 10; gfx_y = 10;
gfx_setfont(1, "Arial", 18);
gfx_drawstr("REACLASSICAL METERING SUITE");

gfx_setfont(1, "Arial", 14);

// LUFS Display
gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = 10; gfx_y = 50;
gfx_drawstr("LUFS Integrated:");
gfx_x = 180; gfx_y = 50;
sprintf(#str, "%.1f LUFS", lufs_i_db);
lufs_i_db > -100 ? (
gfx_drawstr(#str);
) : (
gfx_drawstr("---")
);

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = 10; gfx_y = 80;
gfx_drawstr("LUFS Short-term:");
gfx_x = 180; gfx_y = 80;
sprintf(#str, "%.1f LUFS", lufs_s_db);
lufs_s_db > -100 ? (
gfx_drawstr(#str);
) : (
gfx_drawstr("---")
);
gfx_x = 300; gfx_y = 80;
gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
sprintf(#str, "(max: %.1f)", -0.691+log(lufs_s_sum_max)*10/log(10));
gfx_drawstr(#str);

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = 10; gfx_y = 110;
gfx_drawstr("LUFS Momentary:");
gfx_x = 180; gfx_y = 110;
sprintf(#str, "%.1f LUFS", lufs_m_db);
lufs_m_db > -100 ? (
gfx_drawstr(#str);
) : (
gfx_drawstr("---")
);
gfx_x = 300; gfx_y = 110;
gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
sprintf(#str, "(max: %.1f)", -0.691+log(lufs_m_sum_max)*10/log(10));
gfx_drawstr(#str);

// LRA Display
gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = 10; gfx_y = 140;
gfx_drawstr("LRA (Loudness Range):");
gfx_x = 180; gfx_y = 140;
lra_db_diff > 0 ? (
  sprintf(#str, "%.1f LU", lra_db_diff+0.01);
  gfx_drawstr(#str);
) : (
  gfx_drawstr("---");
);

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = 10; gfx_y = 170;
gfx_drawstr("True Peak L:");
gfx_x = 180; gfx_y = 170;
sprintf(#str, "%.2f dBTP", tp_l_db);
tp_l_db > -1 ? (gfx_r = 1; gfx_g = 0; gfx_b = 0;);
tp_l_db > -150 ? (
gfx_drawstr(#str);
) : (
gfx_drawstr("---")
);

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = 10; gfx_y = 200;
gfx_drawstr("True Peak R:");
gfx_x = 180; gfx_y = 200;
sprintf(#str, "%.2f dBTP", tp_r_db);
tp_r_db > -1 ? (gfx_r = 1; gfx_g = 0; gfx_b = 0;);
tp_r_db > -150 ? (
gfx_drawstr(#str);
) : (
gfx_drawstr("---")
);

// Goniometer
gonio_x = 50;
gonio_y = 270;
gonio_size_display = 180;
gonio_half = gonio_size_display / 2;
gonio_scale = gonio_half * 0.95;

gonio_pos > 0 ? (

gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.15;
gfx_circle(gonio_x + gonio_half, gonio_y + gonio_half, gonio_half, 0);

gfx_r = 0.3; gfx_g = 0.3; gfx_b = 0.3;
gfx_line(gonio_x + gonio_half*0.5, gonio_y + gonio_half*0.5,
         gonio_x + gonio_half*1.5, gonio_y + gonio_half*1.5);
gfx_line(gonio_x + gonio_half*0.5, gonio_y + gonio_half*1.5,
         gonio_x + gonio_half*1.5, gonio_y + gonio_half*0.5);

gfx_r = 0.25; gfx_g = 0.25; gfx_b = 0.25;
gfx_line(gonio_x + gonio_half, gonio_y, gonio_x + gonio_half, gonio_y + gonio_size_display);
gfx_line(gonio_x, gonio_y + gonio_half, gonio_x + gonio_size_display, gonio_y + gonio_half);

gfx_r = 0; gfx_g = 0.6; gfx_b = 1;
gfx_a = 0.6;
i = 0;
rot = -45 * 0.017453292;
samples_to_draw = gonio_pos;
loop(samples_to_draw,
  idx = i;
  L = gonio_buffer_L[idx];
  R = gonio_buffer_R[idx];

  // --- Normalize L and R to keep the plot inside bounding box ---
  peak = max(abs(L), abs(R));
  peak > 1.5 ? (L /= peak; R /= peak;);

  s0 = sign(L);
  s1 = sign(R);
  R != 0 ? angle = atan(L / R) : (L > 0 ? angle = 1.570796327 : angle = 4.71238898);
  (s0 == 1 && s1 == -1) || (s0 == -1 && s1 == -1) ? angle += 3.141592654;
  s0 == -1 && s1 == 1 ? angle += 6.283185307;
  L == 0 ? (R > 0 ? angle = 0 : angle = 3.141592654);

  radius = sqrt(L*L + R*R);
  angle -= rot;

  vert = cos(angle) * radius;
  horiz = sin(angle) * radius;

  plot_x = gonio_x + gonio_half + vert * gonio_scale;
  plot_y = gonio_y + gonio_half - horiz * gonio_scale;

  i > 0 ? (
    gfx_line(last_x, last_y, plot_x, plot_y);
  );

  last_x = plot_x;
  last_y = plot_y;

  i += 1;
);

gfx_a = 1;
gfx_r = 0.8; gfx_g = 0.8; gfx_b = 0.8;
gfx_x = gonio_x + gonio_half*0.3; gfx_y = gonio_y + gonio_half*0.4;
gfx_drawstr("L");
gfx_x = gonio_x + gonio_half*1.6; gfx_y = gonio_y + gonio_half*0.4;
gfx_drawstr("R");
gfx_x = gonio_x + gonio_half - 5; gfx_y = gonio_y;
gfx_drawstr("M");
gfx_x = gonio_x; gfx_y = gonio_y + gonio_half - 5;
gfx_drawstr(" +S");
gfx_x = gonio_x + gonio_size_display - 20; gfx_y = gonio_y + gonio_half - 5;
gfx_drawstr("-S");

gonio_pos = 0;

);


gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = gonio_x + gonio_half - 40; gfx_y = gonio_y + gonio_size_display + 10;
gfx_drawstr("Goniometer");

// Phase Meter
phase_meter_x = 328;
phase_meter_y = 350;
phase_meter_w = 250;
phase_meter_h = 30;

gfx_r = 0.1; gfx_g = 0.1; gfx_b = 0.1;
gfx_rect(phase_meter_x, phase_meter_y, phase_meter_w, phase_meter_h);

gfx_r = 0.5; gfx_g = 0.5; gfx_b = 0.5;
gfx_line(phase_meter_x + phase_meter_w/2, phase_meter_y, phase_meter_x + phase_meter_w/2, phase_meter_y + phase_meter_h);

phase_pos = phase_meter_x + phase_meter_w/2 + (phase_correlation * phase_meter_w/2);
phase_correlation < 0 ? (
  gfx_r = 1; gfx_g = 0.6; gfx_b = 0;
) : (
  gfx_r = 0; gfx_g = 0.6; gfx_b = 1;
);
gfx_rect(phase_pos - 2, phase_meter_y, 4, phase_meter_h);

gfx_r = 0.8; gfx_g = 0.8; gfx_b = 0.8;
gfx_x = phase_meter_x; gfx_y = phase_meter_y + phase_meter_h + 5;
gfx_drawstr("-1");
gfx_x = phase_meter_x + phase_meter_w - 15; gfx_y = phase_meter_y + phase_meter_h + 5;
gfx_drawstr("+1");
gfx_x = phase_meter_x + phase_meter_w/2 - 5; gfx_y = phase_meter_y + phase_meter_h + 5;
gfx_drawstr("0");

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = phase_meter_x + 30; gfx_y = phase_meter_y - 50;
gfx_drawstr("Phase Correlation:");
gfx_x = phase_meter_x + 175; gfx_y = phase_meter_y - 50;
sprintf(#str, "%.3f", phase_correlation);
phase_correlation < 0 ? (gfx_r = 1; gfx_g = 0.5; gfx_b = 0;);
gfx_drawstr(#str);


mtstart     = gfx_texth * 3;
mtrange     = gfx_w/2.5;
// Place the bitmeter a bit higher
mtvalstart  = gfx_h - 75;        // meter Y-position
mtvalrange  = 600;                // how tall the meter is

i = 0;
loop(65,

  x = mtstart + mtrange*(i-1)/64;
  y = mtvalstart;

  tick = !(i&7);

  tick ?
  (
    // measure the number width
    sprintf(#txt, "%d", i);
    gfx_measurestr(#txt, tw, th);

    // center it on the tick
    gfx_x = x - tw*0.5;
    gfx_y = y + gfx_texth;

    gfx_r = 0; gfx_g = 0.6; gfx_b = 1;
    gfx_drawstr(#txt);
  );

  i > 0 ?
  (
    val = bbuf[64-i];

    val > 0.0 ?
    (
      gfx_r = 0; gfx_g = tick ? 1.0 : 0.625; gfx_b = 1;
    ) : (
      gfx_r = gfx_g = gfx_b = tick ? 0.75 : 0.5;
    );

    gfx_x = x;
    gfx_y = y;

    gfx_lineto(x, y - 2 - mtvalrange*0.1*val);
  );

  i += 1;
);

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_setfont(1, "Arial", 14);
gfx_x = mtstart + mtrange * 0.44;  // center horizontally
gfx_y = gfx_h-35;               // safely inside window
gfx_drawstr("Bitmeter", 1);

gfx_ext_retina != last_gfx_ext_retina ? (
  last_gfx_ext_retina = gfx_ext_retina;
   
  gfx_ext_retina > 1 ? (
    gfx_setfont(1,"Arial",20,'b');
    gfx_setfont(2,"Arial",18,'b');
  ) : (
    gfx_setfont(1,"Arial",12,'b');
    gfx_setfont(2,"Arial",10,'b');
  );
  gfx_setfont(1);
);

actual_width = gfx_w / gfx_ext_retina;
actual_height = gfx_h / gfx_ext_retina;

// Calculage compact view flags
// These are used to disable certain elements for graceful visual shrinking
compact_width = actual_width < 600;
compact_height = actual_height < 320;

gfx_ext_retina != 2 ? (
  very_compact_width = (actual_width < 450);
  very_compact_height = (actual_height < 240);
) : (
  very_compact_width = (actual_width < 300);
  very_compact_height = (actual_height < 160);
);

very_compact_width | very_compact_height ? (
  spectrum.bottom_margin = -18 * gfx_ext_retina;
) : ( 
  spectrum.bottom_margin = gfx_h/2;
  spectrum.left_margin = gfx_w/2+40;
  spectrum.top_margin = 20;
  spectrum.right_margin= 20;
);



Display_Mode < 2 ? (
  spectrum.draw(0);
  Spectrum_Mode == 3 || Spectrum_Mode == 6 ? spectrum.draw(1);
);

ht = (gfx_h/2 - spectrum.bottom_margin - gfx_texth) + 2;

dst_a = 0.55 / ht;
gfx_gradrect(0, ht/2, gfx_w, ht/2, 0,0,0,0,    0, 0, 0, 0, 0, 0, 0, dst_a*2); 

!((very_compact_width) | (very_compact_height)) ? (
  spectrum.draw_grid(0);
);

chr = gfx_getchar();

mouse_cap & 8 ? (
  do_listen = 1;
  draw_listen_helper();

  mw = mouse_wheel;
  md = -(mw - last_wheel) / 120;
  last_wheel = mw;

  listen_width += md / 200;
  listen_width = min(0.30, listen_width);
  listen_width = max(0.01, listen_width);

) : do_listen = 0;

!((compact_width) | (compact_height)) ? (
  mouse_x >= 0 && mouse_x < gfx_w && mouse_y >=0 && mouse_y < gfx_h ? (
    note_select = Show_Piano ? spectrum.draw_piano() : 0;
  ) : note_select = 0;
);

draw_info_panel(note_select);

note_select == 0 ? (
  draw_mouse_crosshair();
); 

!((very_compact_width) | (very_compact_height)) ? (
  gfx_ext_retina == 2 ? (menu.x = gfx_w - 140; menu.width = 120;) : (menu.x = gfx_w - 100; menu.width = 80;);
  menu.draw_menu_button();
  menu.handle_menu_button();

  gfx_ext_retina == 2 ? (peaks.x = gfx_w - 240; peaks.width = 100;) : (peaks.x = gfx_w - 200; peaks.width = 60;);
  peaks.draw_peak_button();
  peaks.handle_peak_button();
);

has_click = (mouse_cap&1 && !last_cap) ? 1 : 0;
has_click && mouse_x < 375 && mouse_y < 225 ? Reset();
last_cap = mouse_cap;
