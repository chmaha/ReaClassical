NoIndex: true
desc:ReaClassical Metering Suite (chmaha)
author: chmaha
about:
  Released under GPLv3 license
  
options:no_meter

@init

<?
  nch = max(max_nch,64); // maximum channel count
  sinc_sz = 32; // true peak interpolation size
  use_mem_sinc = sinc_sz>32;

  printf("sinc_sz = %d;\n",sinc_sz);

 function do_all_channels(fmt) local(p x c) global(nch) (
   p=x=0;
   while (x < nch) (
     p+=1;
     x>0 ? printf("num_ch > %d ? ( ",x);
     c = x>=24 ? 8 : x>=8 ? 4 : 2;
     loop(c, printf(fmt,x,x); x+=1);
     printf("\n");
   );
   loop(p-1,printf(")"));
 );
?>

// Constants
WANT_INTEGRATED_ALWAYS=0;
PEAK_METER_DECAY=0.150;
LOUD_METER_UPDATE=0.100;
LOUD_METER_SPEED=0.075;
NUM_BINS=1024;
BINS_PER_DB=10;
DB_PER_BIN=1/BINS_PER_DB;
cfg_peak = 1;
ext_noinit=1;
gfx_clear=-1;
ext_nodenorm=1;
cfg_reinit=1;
attackms=50.0;
decayms=300.0;
mv=pow(2,63);

// Memory allocation
function alloc(sz) (
  memset((alloc.top += sz) - sz, 0, sz);
);

function alloc(sz) global()
(
  memset((this.top+=sz)-sz,0,sz);
);

// sinc filter for true peak
function sinc_gen_val() global(srate sinc_sz) local(sincpos windowpos) instance(slice_pos) (
  windowpos = (2.0 * $pi / sinc_sz) * slice_pos;
  sincpos = $pi * (slice_pos - sinc_sz * .5);
  slice_pos += 1;
  (0.53836 - cos(windowpos)*0.46164) * sin(sincpos) / sincpos;
);

function sinc_gen_slice(cs, o*) instance(sinc_gen_val slice_pos) local(x) global(sinc_sz) (
  slice_pos = cs;
<? 
  use_mem_sinc ? (
    printf("o.v = alloc(sinc_sz);  loop(x=0;sinc_sz, o.v[x] = sinc_gen_val(); x+=1); ");
  ) : (
    loop(x=0;sinc_sz, printf("o.v%02d = sinc_gen_val();%s",x,(x&3)==3?"\n": " "); x += 1)
  );
?>
);

function sinc_init() global(srate) instance(sinc_gen_slice) (
  sinc_gen_slice(srate < 96000 ? .25 : .5,this.s1);
  srate < 96000 ? (
    sinc_gen_slice(.5, this.s2);
    sinc_gen_slice(.75, this.s3);
  );
);

<?
 function emit_sinc(hist, t) (
   use_mem_sinc ? (
    printf("abs(mem_multiply_sum(%s.v,%s.h,sinc_sz))",t,hist);
   ) : (
     printf("abs(");
     loop(x=0;sinc_sz, printf("%s.h%02d * %s.v%02d%s",hist,x,t,x,x==sinc_sz-1?"":(x&3)==3?" +\n":" + "); x+=1);
     printf(")");
   );
 );
?>

function init(chidx)
(
  this.chan=chidx;
  this.wt = chidx < 3 || num_ch < 6 ? 1 : chidx == 3 ? 0 : sqrt(2);
  this.f1p1=this.f1p2=this.f2p1=this.f2p2=0;
  this.pkval=this.hipkval=this.clips=0;
  this.ch_lufs_sum=this.ch_rms_sum=0;
  <? 
    use_mem_sinc ? (
      printf("this.h = alloc(sinc_sz);\n"); 
    ) : ( 
      loop(x=0;sinc_sz, printf("this.h%02d =%s",x,x==sinc_sz-1 ? " 0" : (x&7)==7 ? "\n" : " "); x+=1);
    );
  ?>
);

function decay()
(
  this.pkval *= pk_decay;
);

function copypks() global(pk hipk clip_cnt) (
  pk[this.chan] = this.pkval;
  hipk[this.chan] = this.hipkval;
  clip_cnt[this.chan] = this.clips;
);

function proc(lspl)
  local(pspl f1p0 f2p0)
  instance(wt ch_rms_sum ch_lufs_sum pkval hipkval clips
           f1p1 f1p2 f2p1 f2p2)
  global(f1a1 f1a2 f1b0 f1b1 f1b2
         f2a1 f2a2 f2b0 f2b1 f2b2
         srate cfg_peak
         lval rval win_pos global_peak sinc_sz
         sinc.s1* sinc.s2* sinc.s3*
         )
(
  cfg_peak == 1 || cfg_peak == 2 ? (
    <?
      use_mem_sinc ? (
        printf("mem_insert_shuffle(this.h, sinc_sz, lspl);");
      ) : (
        loop(x=sinc_sz-1;sinc_sz-1, printf("this.h%02d = this.h%02d;%s",x,x-1, (x&3)==0 ? "\n" : " "); x-= 1; );
        printf(" this.h00 = lspl;");
      );
    ?>
    pspl = max(
        abs(this.h<? printf(use_mem_sinc ? "[%d]" : "%02d",sinc_sz/2) ?> ),
        <? emit_sinc("this","sinc.s1") ?>
       );
    srate < 96000 ? pspl = max(pspl,max( <? emit_sinc("this","sinc.s2") ?>,  <? emit_sinc("this","sinc.s3") ?>));
  ) : 
  cfg_peak == 3 || cfg_peak == 4 ? (
    pspl=abs(lspl);
  );
  cfg_peak ? (
    pspl > pkval ? (
      pkval=pspl;
      pspl > hipkval ? (
        hipkval=pspl;
        global_peak = max(global_peak,pspl);
      );
    );
    pspl > 1.0 ? clips += 1;
  );

  win_pos == 0 ? ch_rms_sum=ch_lufs_sum=0;

  rval += (ch_rms_sum += lspl*lspl);
  
  lspl *= wt;

  f1p0=lspl-f1a1*f1p1-f1a2*f1p2;
  lspl=f1b0*f1p0+f1b1*f1p1+f1b2*f1p2;
  f1p2=f1p1;
  f1p1=f1p0;
  
  f2p0=lspl-f2a1*f2p1-f2a2*f2p2;
  lspl=f2b0*f2p0+f2b1*f2p1+f2b2*f2p2;
  f2p2=f2p1;
  f2p1=f2p0;

  lval += (ch_lufs_sum += lspl*lspl);
);

function init_lufs_filters()
  local(Vh Vb db f0 Q K a0)
  global(f1a1 f1a2 f1b0 f1b1 f1b2
         f2a1 f2a2 f2b0 f2b1 f2b2 srate)
(
  // f1,f2 could be combined into a 5th order filter

  db=3.999843853973347;
  f0=1681.974450955533;
  Q=0.7071752369554196;
  K=tan($pi*f0/srate);
  Vh=pow(10, db/20);
  Vb=pow(Vh, 0.4996667741545416);
  a0=1+K/Q+K*K;
  f1a1=2*(K*K-1)/a0;
  f1a2=(1-K/Q+K*K)/a0;
  f1b0=(Vh+Vb*K/Q+K*K)/a0;
  f1b1=2*(K*K-Vh)/a0;
  f1b2=(Vh-Vb*K/Q+K*K)/a0;

  f0=38.13547087602444;
  Q=0.5003270373238773;
  K=tan($pi*f0/srate);
  f2a1=2*(K*K-1)/(1+K/Q+K*K);
  f2a2=(1-K/Q+K*K)/(1+K/Q+K*K);
  f2b0=1;
  f2b1=-2;
  f2b2=1;
);

function Reset() (
init_lufs_filters();

  alloc.top=0;
  pk=alloc(<?printf("%d",nch)?>);
  hipk=alloc(<?printf("%d",nch)?>);
  clip_cnt=alloc(<?printf("%d",nch)?>);
  sinc.sinc_init();

  m_win_cnt=0.4/LOUD_METER_UPDATE;
  s_win_cnt=3/LOUD_METER_UPDATE;

  win_pos=0;
  win_cnt=0;
  win_len=(LOUD_METER_UPDATE*srate)|0;
  i_win_len=1/(m_win_cnt*win_len);
  i_win_len2=1/(s_win_cnt*win_len);

  rms_m_sum=0;
  rms_m_db=-100;
  rms_m_db_max=-100;
  rms_i_sum=0;
  rms_i_sum_cnt=0;
  rms_i_db=-100;

  lufs_m_sum=0;
  lufs_m_sum_max=0;
  lufs_m_db=-100;
  lufs_s_sum=0;
  lufs_s_sum_max=0;
  lufs_s_db=-100;
  lufs_a_sum=0;
  lufs_a_sum_cnt=0;
  lufs_b_sum=0;
  lufs_b_sum_cnt=0;
  lra_db_diff = 0;
  lra_db_hi = lra_db_lo = lufs_i_db = lufs_m_db = lufs_s_db = -100;

  last_t=0;
  th_lufs_i=th_lufs_s=th_lufs_m=th_rms_i=th_rms_m=0;

  cur_buf=0;
  cur_buf2=0;
  rms_buf=alloc(m_win_cnt);
  lufs_buf=alloc(m_win_cnt);
  lufs_buf2=alloc(s_win_cnt);
  lufs_a_hist=alloc(2*NUM_BINS);
  lufs_b_hist=alloc(NUM_BINS);
  db_hist=alloc(75);
  db_hist_max=0;

  global_peak = 0;

  <? do_all_channels("ch%d.init(%d); "); ?>;

  gonio_size = 4800;
  gonio_buffer_L = alloc(gonio_size);
  gonio_buffer_R = alloc(gonio_size);
  gonio_pos = 0;

  corr_LR_sum = 0;
  corr_LL_sum = 0;
  corr_RR_sum = 0;
  corr_count = 0;
  
bitbuf_len = 64;

bbuf = alloc(bitbuf_len);
tbuf = alloc(bitbuf_len);

memset(bbuf, 0, bitbuf_len);
memset(tbuf, 0, bitbuf_len);
);

Reset();

@block
(num_ch > 0 && num_ch != last_nch) || srate != last_sr ? Reset();
last_nch = num_ch;
last_sr = srate;

cfg_reinit && (play_state&1) ? (
  abs(play_position-last_play_pos) > 0.1 ? Reset();
  last_play_pos=play_position+samplesblock/srate;
);

pk_decay=pow(0.5, samplesblock/srate/PEAK_METER_DECAY);

<? do_all_channels("ch%d.decay(); "); ?>;

dv=1.0/(sqrt(num_ch)*samplesblock);
attack=exp(-log(2.0)*samplesblock/(srate*attackms*0.001));
decay=exp(-log(2.0)*samplesblock/(srate*decayms*0.001));

bat=0;
loop
(
  64,
  bbuf[bat] *= decay;
  v=sqrt(min(tbuf[bat],1.0));
  v > bbuf[bat] ?
  (
    bbuf[bat]=bbuf[bat]*attack+v*(1.0-attack);
  ) : (
    bbuf[bat] < 0.001 ? bbuf[bat]=0.0;
  );
  tbuf[bat]=0.0;
  bat += 1;
);

@sample

rval=lval=0;

<? do_all_channels("ch%d.proc(spl%d); "); ?>;

(win_pos += 1) >= win_len ? (
  win_pos=0;
  win_cnt += 1;

  prev_rval=rms_buf[cur_buf];
  rms_buf[cur_buf]=rval;
  
  prev_lval=lufs_buf[cur_buf];
  lufs_buf[cur_buf]=lval;
  
  prev_lval2=lufs_buf2[cur_buf2];
  lufs_buf2[cur_buf2]=lval;

  (cur_buf += 1) >= m_win_cnt ? cur_buf=0;
  (cur_buf2 += 1) >= s_win_cnt ? cur_buf2=0;

  rms_m_sum += (rval-prev_rval)*i_win_len;
  lufs_m_sum += (lval-prev_lval)*i_win_len;
  lufs_s_sum += (lval-prev_lval2)*i_win_len2;
  
  WANT_INTEGRATED_ALWAYS || (play_state&1) ? (
    rms_i_sum += rms_m_sum;
    rms_i_sum_cnt += 1;
    rms_i_sum > 0 && rms_i_sum_cnt >= m_win_cnt ? (
      rms_i_db=log(rms_i_sum/rms_i_sum_cnt)*10/log(10);
    ) : (
      rms_i_db=-100;
    );
  );
  
  rms_m_sum > 0 && win_cnt >= m_win_cnt ? (
    rms_m_db=log(rms_m_sum)*10/log(10);
    rms_m_db > rms_m_db_max ? rms_m_db_max=rms_m_db;
  ) : (
    rms_m_db=-100;
  );
  
  lufs_m_sum > 0 && win_cnt >= m_win_cnt ? (
    lufs_m_sum > lufs_m_sum_max ? lufs_m_sum_max=lufs_m_sum;
    lufs_m_db=-0.691+log(lufs_m_sum)*10/log(10);

    a = WANT_INTEGRATED_ALWAYS || (play_state&1) ? ((lufs_m_db+70)*BINS_PER_DB)|0 : -1;
    a >= 0 ? (
      a >= NUM_BINS ? a=NUM_BINS-1;
      lufs_a_sum += lufs_m_sum;
      lufs_a_sum_cnt += 1;
      lufs_a_hist[2*a] += 1;
      lufs_a_hist[2*a+1] += lufs_m_sum;
      db_hist_max = max(db_hist_max,db_hist[min(a*DB_PER_BIN,74)] += 1);

      lufs_a_db=-0.691+log(lufs_a_sum/lufs_a_sum_cnt)*10/log(10);
      lufs_a_gate=((lufs_a_db-10+70)*BINS_PER_DB)|0;
      lufs_i_sum=0;
      lufs_i_cnt=0;
      bin=max(lufs_a_gate,0);
      loop(NUM_BINS-bin,
        lufs_i_cnt += lufs_a_hist[2*bin];
        lufs_i_sum += lufs_a_hist[2*bin+1];
        bin += 1;
      );
      lufs_i_db=lufs_i_sum > 0 ? -0.691+log(lufs_i_sum/lufs_i_cnt)*10/log(10) : -100;
    );
  ) : (
    lufs_m_db=-100;
  );

  lufs_s_sum > 0 && win_cnt >= s_win_cnt ? (
    lufs_s_sum > lufs_s_sum_max ? lufs_s_sum_max=lufs_s_sum;
    lufs_s_db=-0.691+log(lufs_s_sum)*10/log(10);

    b = WANT_INTEGRATED_ALWAYS || (play_state&1) ? ((lufs_s_db+70)*BINS_PER_DB)|0 : -1;
    b >= 0 ? (
      b >= NUM_BINS ? b=NUM_BINS-1;
      lufs_b_sum += lufs_s_sum;
      lufs_b_sum_cnt += 1;
      lufs_b_hist[b] += 1;

      lufs_b_db=-0.691+log(lufs_b_sum/lufs_b_sum_cnt)*10/log(10);
      lufs_b_gate=((lufs_b_db-20+70)*BINS_PER_DB)|0;

      lra_cnt=0;
      bin=max(lufs_b_gate,0);
      loop(NUM_BINS-bin,
        lra_cnt += lufs_b_hist[bin];
        bin += 1;
      );
      lra_cnt >= 20 ? (
        lra_cnt_lo=lra_cnt_hi=0;
        bin=lufs_b_gate;
        while(bin < NUM_BINS && lra_cnt_lo < lra_cnt*0.10)
        (
          lra_cnt_lo += lufs_b_hist[bin];
          bin += 1;
        );
        bin_lo=bin-1;
        bin=NUM_BINS-1;
        while(bin >= lufs_b_gate && lra_cnt_hi < lra_cnt*0.05)
        (
          lra_cnt_hi += lufs_b_hist[bin];
          bin -= 1;
        );
        bin_hi=bin+1;
        lra_db_lo=bin_lo*DB_PER_BIN-70;
        lra_db_hi=bin_hi*DB_PER_BIN-70;
        lra_db_diff = lra_db_hi-lra_db_lo;
      );
    );
  ) : (
    lufs_s_db=-100;
  );
);

tp_l_db = hipk[0] > 0 ? 20.0 * log(hipk[0]) / log(10) : -200.0;
tp_r_db = num_ch > 1 && hipk[1] > 0 ? 20.0 * log(hipk[1]) / log(10) : -200.0;

// Phase correlation
corr_LR_sum += spl0 * spl1;
corr_LL_sum += spl0 * spl0;
corr_RR_sum += spl1 * spl1;

(corr_count += 1) > 50000 ? (
    corr_LR_sum *= 0.5;
    corr_LL_sum *= 0.5;
    corr_RR_sum *= 0.5;
    corr_count = 25000;
);

den = sqrt(corr_LL_sum * corr_RR_sum);
phase_correlation = den > 0 ? (corr_LR_sum / den) : 0;
phase_correlation = min(max(phase_correlation, -1), 1);

// Goniometer
gonio_buffer_L[gonio_pos] = spl0;
gonio_buffer_R[gonio_pos] = spl1;
gonio_pos += 1;
gonio_pos >= gonio_size ? gonio_pos = 0;

c=0;
loop
(
  num_ch,
  v=abs(spl(c))*mv;
  bat=0;
  v > 0.0 ? loop
  (
    64,
    nv=floor(v*0.5);
    nv*2.0 != v ? tbuf[bat] += dv;
    v=nv;
    bat += 1;
  );
  c += 1;
);

@gfx 640 625
gfx_w != 640 || gfx_h != 625 ? (
  gfx_w = 640;
  gfx_h = 625;
);

<? do_all_channels("ch%d.copypks(); ");?>;

t=time_precise();
speed = last_t ? 1.0-pow(0.5, (t-last_t)/LOUD_METER_SPEED) : 1;
last_t=t;

nch = cfg_mono ? 1 : max(num_ch,2);

// Fade for goniometer trail
gfx_r = 0; gfx_g = 0; gfx_b = 0;
gfx_a = 0.025;
gfx_x = 0; gfx_y = 0;
gfx_rectto(gfx_w, gfx_h);
gfx_a = 1;

// Clear text areas
gfx_r = 0.05; gfx_g = 0.05; gfx_b = 0.05;
gfx_rect(0, 0, gfx_w, 260);
gfx_rect(340, 295, 260, 30);
gfx_rect(0, 455, gfx_w, gfx_h);

// Title
gfx_r = 0; gfx_g = 0.6; gfx_b = 1;
gfx_x = 10; gfx_y = 10;
gfx_setfont(1, "Arial", 18);
gfx_drawstr("REACLASSICAL METERING SUITE");

gfx_setfont(1, "Arial", 14);

// LUFS Display
gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = 10; gfx_y = 50;
gfx_drawstr("LUFS Integrated:");
gfx_x = 180; gfx_y = 50;
sprintf(#str, "%.1f LUFS", lufs_i_db);
lufs_i_db > -100 ? (
gfx_drawstr(#str);
) : (
gfx_drawstr("---")
);

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = 10; gfx_y = 80;
gfx_drawstr("LUFS Short-term:");
gfx_x = 180; gfx_y = 80;
sprintf(#str, "%.1f LUFS", lufs_s_db);
lufs_s_db > -100 ? (
gfx_drawstr(#str);
) : (
gfx_drawstr("---")
);
gfx_x = 300; gfx_y = 80;
gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
sprintf(#str, "(max: %.1f)", -0.691+log(lufs_s_sum_max)*10/log(10));
gfx_drawstr(#str);

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = 10; gfx_y = 110;
gfx_drawstr("LUFS Momentary:");
gfx_x = 180; gfx_y = 110;
sprintf(#str, "%.1f LUFS", lufs_m_db);
lufs_m_db > -100 ? (
gfx_drawstr(#str);
) : (
gfx_drawstr("---")
);
gfx_x = 300; gfx_y = 110;
gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
sprintf(#str, "(max: %.1f)", -0.691+log(lufs_m_sum_max)*10/log(10));
gfx_drawstr(#str);

// LRA Display
gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = 10; gfx_y = 140;
gfx_drawstr("LRA (Loudness Range):");
gfx_x = 180; gfx_y = 140;
lra_db_diff > 0 ? (
  sprintf(#str, "%.1f LU", lra_db_diff+0.01);
  gfx_drawstr(#str);
) : (
  gfx_drawstr("---");
);

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = 10; gfx_y = 170;
gfx_drawstr("True Peak L:");
gfx_x = 180; gfx_y = 170;
sprintf(#str, "%.2f dBTP", tp_l_db);
tp_l_db > -1 ? (gfx_r = 1; gfx_g = 0; gfx_b = 0;);
tp_l_db > -150 ? (
gfx_drawstr(#str);
) : (
gfx_drawstr("---")
);

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = 10; gfx_y = 200;
gfx_drawstr("True Peak R:");
gfx_x = 180; gfx_y = 200;
sprintf(#str, "%.2f dBTP", tp_r_db);
tp_r_db > -1 ? (gfx_r = 1; gfx_g = 0; gfx_b = 0;);
tp_r_db > -150 ? (
gfx_drawstr(#str);
) : (
gfx_drawstr("---")
);

// Goniometer
gonio_x = 50;
gonio_y = 270;
gonio_size_display = 180;
gonio_half = gonio_size_display / 2;
gonio_scale = gonio_half * 0.95;

gonio_pos > 0 ? (

gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.15;
gfx_circle(gonio_x + gonio_half, gonio_y + gonio_half, gonio_half, 0);

gfx_r = 0.3; gfx_g = 0.3; gfx_b = 0.3;
gfx_line(gonio_x + gonio_half*0.5, gonio_y + gonio_half*0.5,
         gonio_x + gonio_half*1.5, gonio_y + gonio_half*1.5);
gfx_line(gonio_x + gonio_half*0.5, gonio_y + gonio_half*1.5,
         gonio_x + gonio_half*1.5, gonio_y + gonio_half*0.5);

gfx_r = 0.25; gfx_g = 0.25; gfx_b = 0.25;
gfx_line(gonio_x + gonio_half, gonio_y, gonio_x + gonio_half, gonio_y + gonio_size_display);
gfx_line(gonio_x, gonio_y + gonio_half, gonio_x + gonio_size_display, gonio_y + gonio_half);

gfx_r = 0; gfx_g = 0.6; gfx_b = 1;
gfx_a = 0.6;
i = 0;
rot = -45 * 0.017453292;
samples_to_draw = gonio_pos;
loop(samples_to_draw,
  idx = i;
  L = gonio_buffer_L[idx];
  R = gonio_buffer_R[idx];

  s0 = sign(L);
  s1 = sign(R);
  R != 0 ? angle = atan(L / R) : (L > 0 ? angle = 1.570796327 : angle = 4.71238898);
  (s0 == 1 && s1 == -1) || (s0 == -1 && s1 == -1) ? angle += 3.141592654;
  s0 == -1 && s1 == 1 ? angle += 6.283185307;
  L == 0 ? (R > 0 ? angle = 0 : angle = 3.141592654);

  radius = sqrt(L*L + R*R);
  angle -= rot;

  vert = cos(angle) * radius;
  horiz = sin(angle) * radius;

  plot_x = gonio_x + gonio_half + vert * gonio_scale;
  plot_y = gonio_y + gonio_half - horiz * gonio_scale;

  i > 0 ? (
    gfx_line(last_x, last_y, plot_x, plot_y);
  );

  last_x = plot_x;
  last_y = plot_y;

  i += 1;
);

gfx_a = 1;
gfx_r = 0.8; gfx_g = 0.8; gfx_b = 0.8;
gfx_x = gonio_x + gonio_half*0.3; gfx_y = gonio_y + gonio_half*0.4;
gfx_drawstr("L");
gfx_x = gonio_x + gonio_half*1.6; gfx_y = gonio_y + gonio_half*0.4;
gfx_drawstr("R");
gfx_x = gonio_x + gonio_half - 5; gfx_y = gonio_y;
gfx_drawstr("M");
gfx_x = gonio_x; gfx_y = gonio_y + gonio_half - 5;
gfx_drawstr(" +S");
gfx_x = gonio_x + gonio_size_display - 20; gfx_y = gonio_y + gonio_half - 5;
gfx_drawstr("-S");

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = gonio_x + gonio_half - 40; gfx_y = gonio_y + gonio_size_display + 10;
gfx_drawstr("Goniometer");

gonio_pos = 0;

);

// Phase Meter
phase_meter_x = 328;
phase_meter_y = 350;
phase_meter_w = 250;
phase_meter_h = 30;

gfx_r = 0.1; gfx_g = 0.1; gfx_b = 0.1;
gfx_rect(phase_meter_x, phase_meter_y, phase_meter_w, phase_meter_h);

gfx_r = 0.5; gfx_g = 0.5; gfx_b = 0.5;
gfx_line(phase_meter_x + phase_meter_w/2, phase_meter_y, phase_meter_x + phase_meter_w/2, phase_meter_y + phase_meter_h);

phase_pos = phase_meter_x + phase_meter_w/2 + (phase_correlation * phase_meter_w/2);
phase_correlation < 0 ? (
  gfx_r = 1; gfx_g = 0.6; gfx_b = 0;
) : (
  gfx_r = 0; gfx_g = 0.6; gfx_b = 1;
);
gfx_rect(phase_pos - 2, phase_meter_y, 4, phase_meter_h);

gfx_r = 0.8; gfx_g = 0.8; gfx_b = 0.8;
gfx_x = phase_meter_x; gfx_y = phase_meter_y + phase_meter_h + 5;
gfx_drawstr("-1");
gfx_x = phase_meter_x + phase_meter_w - 15; gfx_y = phase_meter_y + phase_meter_h + 5;
gfx_drawstr("+1");
gfx_x = phase_meter_x + phase_meter_w/2 - 5; gfx_y = phase_meter_y + phase_meter_h + 5;
gfx_drawstr("0");

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = phase_meter_x + 30; gfx_y = phase_meter_y - 50;
gfx_drawstr("Phase Correlation:");
gfx_x = phase_meter_x + 175; gfx_y = phase_meter_y - 50;
sprintf(#str, "%.3f", phase_correlation);
phase_correlation < 0 ? (gfx_r = 1; gfx_g = 0.5; gfx_b = 0;);
gfx_drawstr(#str);


mtstart     = gfx_texth * 3;
mtrange     = gfx_w - gfx_texth * 6;
// Place the bitmeter a bit higher
mtvalstart  = gfx_h - 75;        // meter Y-position
mtvalrange  = 600;                // how tall the meter is

i = 0;
loop(65,

  x = mtstart + mtrange*(i-1)/64;
  y = mtvalstart;

  tick = !(i&7);

  tick ?
  (
    // measure the number width
    sprintf(#txt, "%d", i);
    gfx_measurestr(#txt, tw, th);

    // center it on the tick
    gfx_x = x - tw*0.5;
    gfx_y = y + gfx_texth;

    gfx_r = 0; gfx_g = 0.6; gfx_b = 1;
    gfx_drawstr(#txt);
  );

  i > 0 ?
  (
    val = bbuf[64-i];

    val > 0.0 ?
    (
      gfx_r = 0; gfx_g = tick ? 1.0 : 0.625; gfx_b = 1;
    ) : (
      gfx_r = gfx_g = gfx_b = tick ? 0.75 : 0.5;
    );

    gfx_x = x;
    gfx_y = y;

    gfx_lineto(x, y - 2 - mtvalrange*0.1*val);
  );

  i += 1;
);

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_setfont(1, "Arial", 14);
gfx_x = mtstart + mtrange * 0.44;  // center horizontally
gfx_y = gfx_h-35;               // safely inside window
gfx_drawstr("Bitmeter", 1);

has_click = (mouse_cap&1 && !last_cap) ? 1 : 0;
has_click ? Reset();
last_cap = mouse_cap;
