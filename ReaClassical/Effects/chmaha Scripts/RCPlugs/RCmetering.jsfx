NoIndex: true
desc:ReaClassical Metering Suite (chmaha)
author: chmaha
about:
  Released under GPLv3 license
  
options:no_meter

@init
ext_noinit = 1;
gfx_clear = -1;
ext_nodenorm=1;

attackms=50.0;
decayms=300.0;
mv=pow(2,63);

// Memory allocation
function alloc(sz) (
  memset((alloc.top += sz) - sz, 0, sz);
);

// Constants
LOUD_METER_UPDATE = 0.100;

// K-weighting filter coefficients
f1_b0 = 1.53512485958697;
f1_b1 = -2.69169618940638;
f1_b2 = 1.19839281085285;
f1_a1 = -1.69065929318241;
f1_a2 = 0.73248077421585;

f2_b0 = 1.0;
f2_b1 = -2.0;
f2_b2 = 1.0;
f2_a1 = -1.99004745483398;
f2_a2 = 0.99007225036621;

sinc_sz = 32;

// Helper functions
function mem_insert_shuffle(buf, len, val) local(i) (
  i = len - 1;
  loop(len - 1,
    buf[i] = buf[i-1];
    i -= 1;
  );
  buf[0] = val;
);

function mem_multiply_sum(a, b, len) local(sum i) (
  sum = 0;
  i = 0;
  loop(len,
    sum += a[i] * b[i];
    i += 1;
  );
  sum;
);

// Sinc generation
function sinc_gen_val() local(sincpos windowpos) instance(slice_pos) (
  windowpos = (2.0 * $pi / sinc_sz) * slice_pos;
  sincpos = $pi * (slice_pos - sinc_sz * 0.5);
  slice_pos += 1;
  (0.53836 - cos(windowpos)*0.46164) * sin(sincpos) / sincpos;
);

function sinc_gen_slice(cs, mem_ptr) instance(slice_pos) local(x) (
  slice_pos = cs;
  x = 0;
  loop(sinc_sz,
    mem_ptr[x] = sinc_gen_val();
    x += 1;
  );
);

function sinc_init() local(s1_ptr s2_ptr s3_ptr) (
  s1_ptr = alloc(sinc_sz);
  this.s1 = s1_ptr;

  srate < 96000 ? (
    s2_ptr = alloc(sinc_sz);
    s3_ptr = alloc(sinc_sz);
    this.s2 = s2_ptr;
    this.s3 = s3_ptr;

    sinc_gen_slice(0.25, s1_ptr);
    sinc_gen_slice(0.5, s2_ptr);
    sinc_gen_slice(0.75, s3_ptr);
  ) : (
    sinc_gen_slice(0.5, s1_ptr);
    this.s2 = 0;
    this.s3 = 0;
  );
);

// Channel initialization
function init_channel(chidx) local(h_ptr) (
  this.chan = chidx;
  this.wt = chidx < 3 || num_ch < 6 ? 1 : chidx == 3 ? 0 : 1.41421356237;
  this.f1p1 = this.f1p2 = this.f2p1 = this.f2p2 = 0;
  this.pkval = this.hipkval = 0;
  this.ch_lufs_sum = 0;

  h_ptr = alloc(sinc_sz);
  this.h = h_ptr;
  memset(h_ptr, 0, sinc_sz);
);

// Process sample through channel
function proc_channel(lspl) local(pspl f1p0 f2p0 temp)
  instance(wt ch_lufs_sum pkval hipkval f1p1 f1p2 f2p1 f2p2 h) (

  mem_insert_shuffle(h, sinc_sz, lspl);

  pspl = max(
    abs(h[sinc_sz/2]),
    abs(mem_multiply_sum(sinc.s1, h, sinc_sz))
  );

  srate < 96000 && sinc.s2 > 0 ? (
    pspl = max(pspl, abs(mem_multiply_sum(sinc.s2, h, sinc_sz)));
    pspl = max(pspl, abs(mem_multiply_sum(sinc.s3, h, sinc_sz)));
  );

  pspl > pkval ? (
    pkval = pspl;
    pspl > hipkval ? hipkval = pspl;
  );

  f1p0 = lspl - f1_a1*f1p1 - f1_a2*f1p2;
  temp = f1_b0*f1p0 + f1_b1*f1p1 + f1_b2*f1p2;
  f1p2 = f1p1;
  f1p1 = f1p0;

  f2p0 = temp - f2_a1*f2p1 - f2_a2*f2p2;
  lspl = f2_b0*f2p0 + f2_b1*f2p1 + f2_b2*f2p2;
  f2p2 = f2p1;
  f2p1 = f2p0;

  lspl *= wt;
  win_pos == 0 ? ch_lufs_sum = 0;
  ch_lufs_sum += lspl * lspl;

  lspl * lspl;
);

function Reset() (
  alloc.top = 0;

  sinc.sinc_init(); 

  m_win_cnt = (0.4 / LOUD_METER_UPDATE)|0;
  s_win_cnt = (3.0 / LOUD_METER_UPDATE)|0;

  win_pos = 0;
  win_cnt = 0;
  win_len = (LOUD_METER_UPDATE * srate)|0;
  i_win_len = 1.0 / (m_win_cnt * win_len);
  i_win_len2 = 1.0 / (s_win_cnt * win_len);

  lufs_buf = alloc(m_win_cnt);
  lufs_buf2 = alloc(s_win_cnt);

  lufs_m_sum = 0;
  lufs_m_sum_max = 0;
  lufs_m_db = -100;
  lufs_m_db_max = -100;

  lufs_s_sum = 0;
  lufs_s_sum_max = 0;
  lufs_s_db = -100;
  lufs_s_db_max = -100;

  // Integrated LUFS histogram
  NUM_BINS = 1024;
  BINS_PER_DB = 10;
  DB_PER_BIN = 1.0 / BINS_PER_DB;
  lufs_a_hist = alloc(2 * NUM_BINS);
  lufs_a_sum = 0;
  lufs_a_sum_cnt = 0;
  lufs_i_db = -100;
  lufs_i_db_max = -100;

  // LRA histogram (for short-term blocks)
  lufs_b_hist = alloc(NUM_BINS);
  lufs_b_sum = 0;
  lufs_b_sum_cnt = 0;
  lra_db_diff = 0;
  lra_db_hi = -100;
  lra_db_lo = -100;

  cur_buf = 0;
  cur_buf2 = 0;

  gonio_size = 4800;
  gonio_buffer_L = alloc(gonio_size);
  gonio_buffer_R = alloc(gonio_size);
  gonio_pos = 0;

  ch0.init_channel(0);
  ch1.init_channel(1);

  corr_LR_sum = 0;
  corr_LL_sum = 0;
  corr_RR_sum = 0;
  corr_count = 0;
  
bitbuf_len = 64;

bbuf = alloc(bitbuf_len);
tbuf = alloc(bitbuf_len);

memset(bbuf, 0, bitbuf_len);
memset(tbuf, 0, bitbuf_len);
);

Reset();

@block
(num_ch > 0 && num_ch != last_nch) || srate != last_sr ? Reset();
last_nch = num_ch;
last_sr = srate;

dv=1.0/(sqrt(num_ch)*samplesblock);
attack=exp(-log(2.0)*samplesblock/(srate*attackms*0.001));
decay=exp(-log(2.0)*samplesblock/(srate*decayms*0.001));

bat=0;
loop
(
  64,
  bbuf[bat] *= decay;
  v=sqrt(min(tbuf[bat],1.0));
  v > bbuf[bat] ?
  (
    bbuf[bat]=bbuf[bat]*attack+v*(1.0-attack);
  ) : (
    bbuf[bat] < 0.001 ? bbuf[bat]=0.0;
  );
  tbuf[bat]=0.0;
  bat += 1;
);

@sample
raw_l = spl0;
raw_r = spl1;
lval = 0;
lval += ch0.proc_channel(spl0);
lval += ch1.proc_channel(spl1);

(win_pos += 1) >= win_len ? (
  win_pos = 0;
  win_cnt += 1;

  window_sum = ch0.ch_lufs_sum + ch1.ch_lufs_sum;

  prev_lval = lufs_buf[cur_buf];
  lufs_buf[cur_buf] = window_sum;

  prev_lval2 = lufs_buf2[cur_buf2];
  lufs_buf2[cur_buf2] = window_sum;

  (cur_buf += 1) >= m_win_cnt ? cur_buf=0;
  (cur_buf2 += 1) >= s_win_cnt ? cur_buf2=0;

  lufs_m_sum += (window_sum - prev_lval) * i_win_len;
  lufs_s_sum += (window_sum - prev_lval2) * i_win_len2;

  // Momentary LUFS (400ms)
  lufs_m_sum > 0 && win_cnt >= m_win_cnt ? (
  lufs_m_sum > lufs_m_sum_max ? lufs_m_sum_max = lufs_m_sum;
    lufs_m_db = -0.691 + log(lufs_m_sum) * 10 / log(10);
    lufs_m_db > lufs_m_db_max ? lufs_m_db_max = lufs_m_db; 
    

    // Integrated LUFS with histogram gating
    a = ((lufs_m_db + 70) * BINS_PER_DB)|0;
    a >= 0 && a < NUM_BINS ? (
      lufs_a_sum += lufs_m_sum;
      lufs_a_sum_cnt += 1;
      lufs_a_hist[2*a] += 1;
      lufs_a_hist[2*a + 1] += lufs_m_sum;

      lufs_a_db = -0.691 + log(lufs_a_sum / lufs_a_sum_cnt) * 10 / log(10);
      lufs_a_gate = ((lufs_a_db - 10 + 70) * BINS_PER_DB)|0;

      lufs_i_sum = 0;
      lufs_i_cnt = 0;
      bin = max(lufs_a_gate, 0);
      loop(NUM_BINS - bin,
        lufs_i_cnt += lufs_a_hist[2*bin];
        lufs_i_sum += lufs_a_hist[2*bin + 1];
        bin += 1;
      );

      lufs_i_sum > 0 ? (
        lufs_i_db = -0.691 + log(lufs_i_sum / lufs_i_cnt) * 10 / log(10);
        lufs_i_db > lufs_i_db_max ? lufs_i_db_max = lufs_i_db;
      ) : (
        lufs_i_db = -100;
      );
    );
  ) : (
    lufs_m_db = -100;
  );

  // Short-term LUFS (3s) and LRA
  lufs_s_sum > 0 && win_cnt >= s_win_cnt ? (
  lufs_s_sum > lufs_s_sum_max ? lufs_s_sum_max = lufs_s_sum;
    lufs_s_db = -0.691 + log(lufs_s_sum) * 10 / log(10);
    lufs_s_db > lufs_s_db_max ? lufs_s_db_max = lufs_s_db;
    

    // LRA histogram - store lufs_s_sum not db value
    b = ((lufs_s_db + 70) * BINS_PER_DB)|0;
    b >= 0 ? (
      b >= NUM_BINS ? b=NUM_BINS-1;
      lufs_b_sum += lufs_s_sum;
      lufs_b_sum_cnt += 1;
      lufs_b_hist[b] += 1;

      // Calculate ungated average
      lufs_b_db = -0.691 + log(lufs_b_sum / lufs_b_sum_cnt) * 10 / log(10);
      
      // Gate at -20 LU relative to ungated average
      lufs_b_gate = ((lufs_b_db - 20 + 70) * BINS_PER_DB)|0;

      // Count total blocks above gate
      lra_cnt = 0;
      bin = max(lufs_b_gate, 0);
      loop(NUM_BINS - bin,
        lra_cnt += lufs_b_hist[bin];
        bin += 1;
      );

      // Need at least 20 blocks for valid LRA
      lra_cnt >= 20 ? (
        // Find 10th percentile (low)
        lra_cnt_lo=lra_cnt_hi=0;
        bin = lufs_b_gate;
        while(bin < NUM_BINS && lra_cnt_lo < lra_cnt * 0.10) (
          lra_cnt_lo += lufs_b_hist[bin];
          bin += 1;
        );
        bin_lo = bin - 1;
        bin = NUM_BINS - 1;
        while(bin >= lufs_b_gate && lra_cnt_hi < lra_cnt * 0.05) (
          lra_cnt_hi += lufs_b_hist[bin];
          bin -= 1;
        );
        bin_hi = bin + 1;

        // Convert bins to dB values
        lra_db_lo = bin_lo * DB_PER_BIN - 70;
        lra_db_hi = bin_hi * DB_PER_BIN - 70;
        lra_db_diff = lra_db_hi-lra_db_lo;
      );
    );
  ) : (
    lufs_s_db = -100;
  );
);

// Phase correlation
corr_LR_sum += spl0 * spl1;
corr_LL_sum += spl0 * spl0;
corr_RR_sum += spl1 * spl1;

(corr_count += 1) > 50000 ? (
    corr_LR_sum *= 0.5;
    corr_LL_sum *= 0.5;
    corr_RR_sum *= 0.5;
    corr_count = 25000;
);

den = sqrt(corr_LL_sum * corr_RR_sum);
phase_correlation = den > 0 ? (corr_LR_sum / den) : 0;
phase_correlation = min(max(phase_correlation, -1), 1);

// Goniometer
gonio_buffer_L[gonio_pos] = spl0;
gonio_buffer_R[gonio_pos] = spl1;
gonio_pos += 1;
gonio_pos >= gonio_size ? gonio_pos = 0;

c=0;
loop
(
  num_ch,
  v=abs(spl(c))*mv;
  bat=0;
  v > 0.0 ? loop
  (
    64,
    nv=floor(v*0.5);
    nv*2.0 != v ? tbuf[bat] += dv;
    v=nv;
    bat += 1;
  );
  c += 1;
);

@gfx 640 625
gfx_w != 640 || gfx_h != 625 ? (
  gfx_w = 640;
  gfx_h = 625;
);

// Fade for goniometer trail
gfx_r = 0; gfx_g = 0; gfx_b = 0;
gfx_a = 0.025;
gfx_x = 0; gfx_y = 0;
gfx_rectto(gfx_w, gfx_h);
gfx_a = 1;

// Clear text areas
gfx_r = 0.05; gfx_g = 0.05; gfx_b = 0.05;
gfx_rect(0, 0, gfx_w, 260);
gfx_rect(340, 295, 260, 30);
gfx_rect(0, 455, gfx_w, gfx_h);

// Title
gfx_r = 0; gfx_g = 0.6; gfx_b = 1;
gfx_x = 10; gfx_y = 10;
gfx_setfont(1, "Arial", 18);
gfx_drawstr("REACLASSICAL METER SUITE");

gfx_setfont(1, "Arial", 14);

// LUFS Display
gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = 10; gfx_y = 50;
gfx_drawstr("LUFS Integrated:");
gfx_x = 180; gfx_y = 50;
sprintf(#str, "%.1f LUFS", lufs_i_db);
gfx_drawstr(#str);

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = 10; gfx_y = 80;
gfx_drawstr("LUFS Short-term:");
gfx_x = 180; gfx_y = 80;
sprintf(#str, "%.1f LUFS", lufs_s_db);
gfx_drawstr(#str);
gfx_x = 300; gfx_y = 80;
gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
sprintf(#str, "(max: %.1f)", lufs_s_db_max);
gfx_drawstr(#str);

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = 10; gfx_y = 110;
gfx_drawstr("LUFS Momentary:");
gfx_x = 180; gfx_y = 110;
sprintf(#str, "%.1f LUFS", lufs_m_db);
gfx_drawstr(#str);
gfx_x = 300; gfx_y = 110;
gfx_r = 0.7; gfx_g = 0.7; gfx_b = 0.7;
sprintf(#str, "(max: %.1f)", lufs_m_db_max);
gfx_drawstr(#str);

// LRA Display
gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = 10; gfx_y = 140;
gfx_drawstr("LRA (Loudness Range):");
gfx_x = 180; gfx_y = 140;
lra_db_diff > 0 ? (
  sprintf(#str, "%.1f LU", lra_db_diff);
  gfx_drawstr(#str);
) : (
  gfx_drawstr("---");
);

// True Peak
tp_l_db = ch0.hipkval > 0 ? 20 * log10(ch0.hipkval) : -150;
tp_r_db = ch1.hipkval > 0 ? 20 * log10(ch1.hipkval) : -150;

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = 10; gfx_y = 170;
gfx_drawstr("True Peak L:");
gfx_x = 180; gfx_y = 170;
sprintf(#str, "%.2f dBTP", tp_l_db);
tp_l_db > -1 ? (gfx_r = 1; gfx_g = 0; gfx_b = 0;);
gfx_drawstr(#str);

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = 10; gfx_y = 200;
gfx_drawstr("True Peak R:");
gfx_x = 180; gfx_y = 200;
sprintf(#str, "%.2f dBTP", tp_r_db);
tp_r_db > -1 ? (gfx_r = 1; gfx_g = 0; gfx_b = 0;);
gfx_drawstr(#str);

// Goniometer
gonio_x = 50;
gonio_y = 270;
gonio_size_display = 180;
gonio_half = gonio_size_display / 2;
gonio_scale = gonio_half * 0.95;

gonio_pos > 0 ? (

gfx_r = 0.15; gfx_g = 0.15; gfx_b = 0.15;
gfx_circle(gonio_x + gonio_half, gonio_y + gonio_half, gonio_half, 0);

gfx_r = 0.3; gfx_g = 0.3; gfx_b = 0.3;
gfx_line(gonio_x + gonio_half*0.5, gonio_y + gonio_half*0.5,
         gonio_x + gonio_half*1.5, gonio_y + gonio_half*1.5);
gfx_line(gonio_x + gonio_half*0.5, gonio_y + gonio_half*1.5,
         gonio_x + gonio_half*1.5, gonio_y + gonio_half*0.5);

gfx_r = 0.25; gfx_g = 0.25; gfx_b = 0.25;
gfx_line(gonio_x + gonio_half, gonio_y, gonio_x + gonio_half, gonio_y + gonio_size_display);
gfx_line(gonio_x, gonio_y + gonio_half, gonio_x + gonio_size_display, gonio_y + gonio_half);

gfx_r = 0; gfx_g = 0.6; gfx_b = 1;
gfx_a = 0.6;
i = 0;
rot = -45 * 0.017453292;
samples_to_draw = gonio_pos;
loop(samples_to_draw,
  idx = i;
  L = gonio_buffer_L[idx];
  R = gonio_buffer_R[idx];

  s0 = sign(L);
  s1 = sign(R);
  R != 0 ? angle = atan(L / R) : (L > 0 ? angle = 1.570796327 : angle = 4.71238898);
  (s0 == 1 && s1 == -1) || (s0 == -1 && s1 == -1) ? angle += 3.141592654;
  s0 == -1 && s1 == 1 ? angle += 6.283185307;
  L == 0 ? (R > 0 ? angle = 0 : angle = 3.141592654);

  radius = sqrt(L*L + R*R);
  angle -= rot;

  vert = cos(angle) * radius;
  horiz = sin(angle) * radius;

  plot_x = gonio_x + gonio_half + vert * gonio_scale;
  plot_y = gonio_y + gonio_half - horiz * gonio_scale;

  i > 0 ? (
    gfx_line(last_x, last_y, plot_x, plot_y);
  );

  last_x = plot_x;
  last_y = plot_y;

  i += 1;
);

gfx_a = 1;
gfx_r = 0.8; gfx_g = 0.8; gfx_b = 0.8;
gfx_x = gonio_x + gonio_half*0.3; gfx_y = gonio_y + gonio_half*0.4;
gfx_drawstr("L");
gfx_x = gonio_x + gonio_half*1.6; gfx_y = gonio_y + gonio_half*0.4;
gfx_drawstr("R");
gfx_x = gonio_x + gonio_half - 5; gfx_y = gonio_y;
gfx_drawstr("M");
gfx_x = gonio_x; gfx_y = gonio_y + gonio_half - 5;
gfx_drawstr(" +S");
gfx_x = gonio_x + gonio_size_display - 20; gfx_y = gonio_y + gonio_half - 5;
gfx_drawstr("-S");

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = gonio_x + gonio_half - 40; gfx_y = gonio_y + gonio_size_display + 10;
gfx_drawstr("Goniometer");

gonio_pos = 0;

);

// Phase Meter
phase_meter_x = 328;
phase_meter_y = 350;
phase_meter_w = 250;
phase_meter_h = 30;

gfx_r = 0.1; gfx_g = 0.1; gfx_b = 0.1;
gfx_rect(phase_meter_x, phase_meter_y, phase_meter_w, phase_meter_h);

gfx_r = 0.5; gfx_g = 0.5; gfx_b = 0.5;
gfx_line(phase_meter_x + phase_meter_w/2, phase_meter_y, phase_meter_x + phase_meter_w/2, phase_meter_y + phase_meter_h);

phase_pos = phase_meter_x + phase_meter_w/2 + (phase_correlation * phase_meter_w/2);
phase_correlation < 0 ? (
  gfx_r = 1; gfx_g = 0.6; gfx_b = 0;
) : (
  gfx_r = 0; gfx_g = 0.6; gfx_b = 1;
);
gfx_rect(phase_pos - 2, phase_meter_y, 4, phase_meter_h);

gfx_r = 0.8; gfx_g = 0.8; gfx_b = 0.8;
gfx_x = phase_meter_x; gfx_y = phase_meter_y + phase_meter_h + 5;
gfx_drawstr("-1");
gfx_x = phase_meter_x + phase_meter_w - 15; gfx_y = phase_meter_y + phase_meter_h + 5;
gfx_drawstr("+1");
gfx_x = phase_meter_x + phase_meter_w/2 - 5; gfx_y = phase_meter_y + phase_meter_h + 5;
gfx_drawstr("0");

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_x = phase_meter_x + 30; gfx_y = phase_meter_y - 50;
gfx_drawstr("Phase Correlation:");
gfx_x = phase_meter_x + 175; gfx_y = phase_meter_y - 50;
sprintf(#str, "%.3f", phase_correlation);
phase_correlation < 0 ? (gfx_r = 1; gfx_g = 0.5; gfx_b = 0;);
gfx_drawstr(#str);


mtstart     = gfx_texth * 3;
mtrange     = gfx_w - gfx_texth * 6;
// Place the bitmeter a bit higher
mtvalstart  = gfx_h - 75;        // meter Y-position
mtvalrange  = 600;                // how tall the meter is

i = 0;
loop(65,

  x = mtstart + mtrange*(i-1)/64;
  y = mtvalstart;

  tick = !(i&7);

  tick ?
  (
    // measure the number width
    sprintf(#txt, "%d", i);
    gfx_measurestr(#txt, tw, th);

    // center it on the tick
    gfx_x = x - tw*0.5;
    gfx_y = y + gfx_texth;

    gfx_r = 0; gfx_g = 0.6; gfx_b = 1;
    gfx_drawstr(#txt);
  );

  i > 0 ?
  (
    val = bbuf[64-i];

    val > 0.0 ?
    (
      gfx_r = 0; gfx_g = tick ? 1.0 : 0.625; gfx_b = 1;
    ) : (
      gfx_r = gfx_g = gfx_b = tick ? 0.75 : 0.5;
    );

    gfx_x = x;
    gfx_y = y;

    gfx_lineto(x, y - 2 - mtvalrange*0.1*val);
  );

  i += 1;
);

gfx_r = 1; gfx_g = 1; gfx_b = 1;
gfx_setfont(1, "Arial", 14);
gfx_x = mtstart + mtrange * 0.44;  // center horizontally
gfx_y = gfx_h-35;               // safely inside window
gfx_drawstr("Bitmeter", 1);

has_click = (mouse_cap&1 && !last_cap) ? 1 : 0;
has_click ? Reset();
last_cap = mouse_cap;
