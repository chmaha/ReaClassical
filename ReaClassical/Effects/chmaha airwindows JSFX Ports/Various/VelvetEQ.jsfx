Version: 1.0
desc:VelvetEQ (chmaha)
author: chmaha
about:
  Uses DSP from airwindows "SmoothEQ3" by Chris Johnson
  https://github.com/airwindows/airwindows/tree/master/plugins/LinuxVST/src/SmoothEQ3 (MIT License)
  JSFX version released under GPLv3 license

slider1:0.5<0,1,0.01>High
slider2:0.5<0,1,0.01>Mid
slider3:0.5<0,1,0.01>Low

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

@init

biq_freq = 0;
biq_reso = 1;
biq_a0 = 2;
biq_a1 = 3;
biq_a2 = 4;
biq_b1 = 5;
biq_b2 = 6;
biq_sL1 = 7;
biq_sL2 = 8;
biq_sR1 = 9;
biq_sR2 = 10;

freemem = 0;
highFast = freemem; freemem += 11;
lowFast = freemem; freemem += 11;

@slider

A = slider1;
B = slider2;
C = slider3;

@block

trebleGain = (A-0.5)*2.0;
trebleGain = 1.0+(trebleGain*abs(trebleGain)*abs(trebleGain));
midGain = (B-0.5)*2.0;
midGain = 1.0+(midGain*abs(midGain)*abs(midGain));
bassGain = (C-0.5)*2.0;
bassGain = 1.0+(bassGain*abs(bassGain)*abs(bassGain));

highFast[biq_freq] = (4000.0/srate);
omega = 2.0*$pi*(4000.0/srate);
K = 2.0 - cos(omega);
highCoef = -sqrt(K*K - 1.0) + K;
lowFast[biq_freq] = (200.0/srate);
omega = 2.0*$pi*(200.0/srate);
K = 2.0 - cos(omega);
lowCoef = -sqrt(K*K - 1.0) + K;
K = tan($pi * highFast[biq_freq]);
norm = 1.0 / (1.0 + K + K*K);
highFast[biq_a0] = K * K * norm;
highFast[biq_a1] = 2.0 * highFast[biq_a0];
highFast[biq_a2] = highFast[biq_a0];
highFast[biq_b1] = 2.0 * (K*K - 1.0) * norm;
highFast[biq_b2] = (1.0 - K + K*K) * norm;
K = tan($pi * lowFast[biq_freq]);
norm = 1.0 / (1.0 + K + K*K);
lowFast[biq_a0] = K * K * norm;
lowFast[biq_a1] = 2.0 * lowFast[biq_a0];
lowFast[biq_a2] = lowFast[biq_a0];
lowFast[biq_b1] = 2.0 * (K*K - 1.0) * norm;
lowFast[biq_b2] = (1.0 - K + K*K) * norm;

@sample
inputSampleL = spl0;
inputSampleR = spl1;

trebleFastL = inputSampleL;
outSample = (trebleFastL * highFast[biq_a0]) + highFast[biq_sL1];
highFast[biq_sL1] = (trebleFastL * highFast[biq_a1]) - (outSample * highFast[biq_b1]) + highFast[biq_sL2];
highFast[biq_sL2] = (trebleFastL * highFast[biq_a2]) - (outSample * highFast[biq_b2]);
midFastL = outSample; trebleFastL -= midFastL;
outSample = (midFastL * lowFast[biq_a0]) + lowFast[biq_sL1];
lowFast[biq_sL1] = (midFastL * lowFast[biq_a1]) - (outSample * lowFast[biq_b1]) + lowFast[biq_sL2];
lowFast[biq_sL2] = (midFastL * lowFast[biq_a2]) - (outSample * lowFast[biq_b2]);
bassFastL = outSample; midFastL -= bassFastL;
trebleFastL = (bassFastL*bassGain) + (midFastL*midGain) + (trebleFastL*trebleGain);

highFastLIIR = (highFastLIIR*highCoef) + (trebleFastL*(1.0-highCoef));
midFastL = highFastLIIR; trebleFastL -= midFastL;
lowFastLIIR = (lowFastLIIR*lowCoef) + (midFastL*(1.0-lowCoef));
bassFastL = lowFastLIIR; midFastL -= bassFastL;
inputSampleL = (bassFastL*bassGain) + (midFastL*midGain) + (trebleFastL*trebleGain);

trebleFastR = inputSampleR;
outSample = (trebleFastR * highFast[biq_a0]) + highFast[biq_sR1];
highFast[biq_sR1] = (trebleFastR * highFast[biq_a1]) - (outSample * highFast[biq_b1]) + highFast[biq_sR2];
highFast[biq_sR2] = (trebleFastR * highFast[biq_a2]) - (outSample * highFast[biq_b2]);
midFastR = outSample; trebleFastR -= midFastR;
outSample = (midFastR * lowFast[biq_a0]) + lowFast[biq_sR1];
lowFast[biq_sR1] = (midFastR * lowFast[biq_a1]) - (outSample * lowFast[biq_b1]) + lowFast[biq_sR2];
lowFast[biq_sR2] = (midFastR * lowFast[biq_a2]) - (outSample * lowFast[biq_b2]);
bassFastR = outSample; midFastR -= bassFastR;
trebleFastR = (bassFastR*bassGain) + (midFastR*midGain) + (trebleFastR*trebleGain);

highFastRIIR = (highFastRIIR*highCoef) + (trebleFastR*(1.0-highCoef));
midFastR = highFastRIIR; trebleFastR -= midFastR;
lowFastRIIR = (lowFastRIIR*lowCoef) + (midFastR*(1.0-lowCoef));
bassFastR = lowFastRIIR; midFastR -= bassFastR;
inputSampleR = (bassFastR*bassGain) + (midFastR*midGain) + (trebleFastR*trebleGain);

spl0 = inputSampleL;
spl1 = inputSampleR;
